{"ast":null,"code":"import _defineProperty from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _ITEM_STATE_ABORTS;\n\nimport { BATCH_STATES, FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { triggerUploaderBatchEvent, getBatchFromState, getIsBatchFinalized } from \"./batchHelpers\";\nimport processFinishedRequest from \"./processFinishedRequest\";\n\nvar abortNonUploadingItem = function abortNonUploadingItem(queue, item, next) {\n  logger.debugLog(\"uploader.queue: aborting \".concat(item.state, \" item  - \"), item); //manually finish request for item that hasnt reached the sender yet\n\n  processFinishedRequest(queue, [{\n    id: item.id,\n    info: {\n      status: 0,\n      state: FILE_STATES.ABORTED,\n      response: \"aborted\"\n    }\n  }], next);\n  return true;\n};\n\nvar ITEM_STATE_ABORTS = (_ITEM_STATE_ABORTS = {}, _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.UPLOADING, function (queue, item) {\n  logger.debugLog(\"uploader.queue: aborting uploading item  - \", item);\n  return queue.getState().aborts[item.id]();\n}), _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.ADDED, abortNonUploadingItem), _defineProperty(_ITEM_STATE_ABORTS, FILE_STATES.PENDING, abortNonUploadingItem), _ITEM_STATE_ABORTS);\n\nvar callAbortOnItem = function callAbortOnItem(queue, id, next) {\n  var state = queue.getState(),\n      item = state.items[id],\n      itemState = item === null || item === void 0 ? void 0 : item.state; //$FlowIssue[prop-missing]\n\n  return ITEM_STATE_ABORTS[itemState] ? //$FlowExpectedError[extra-arg]\n  //$FlowIssue[prop-missing]\n  ITEM_STATE_ABORTS[itemState](queue, item, next) : false;\n};\n\nvar abortAll = function abortAll(queue, next) {\n  var items = queue.getState().items;\n  Object.keys(items).forEach(function (id) {\n    return callAbortOnItem(queue, id, next);\n  });\n  queue.trigger(UPLOADER_EVENTS.ALL_ABORT);\n};\n\nvar abortItem = function abortItem(queue, id, next) {\n  return callAbortOnItem(queue, id, next);\n};\n\nvar abortBatch = function abortBatch(queue, id, next) {\n  var state = queue.getState(),\n      batchData = state.batches[id],\n      batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;\n\n  if (batch && !getIsBatchFinalized(batch)) {\n    queue.updateState(function (state) {\n      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;\n    });\n    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);\n    batch.items.forEach(function (bi) {\n      return callAbortOnItem(queue, bi.id, next);\n    });\n  }\n};\n\nexport { abortAll, abortItem, abortBatch };","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/uploader/lib/esm/queue/abort.js"],"names":["BATCH_STATES","FILE_STATES","logger","UPLOADER_EVENTS","triggerUploaderBatchEvent","getBatchFromState","getIsBatchFinalized","processFinishedRequest","abortNonUploadingItem","queue","item","next","debugLog","state","id","info","status","ABORTED","response","ITEM_STATE_ABORTS","UPLOADING","getState","aborts","ADDED","PENDING","callAbortOnItem","items","itemState","abortAll","Object","keys","forEach","trigger","ALL_ABORT","abortItem","abortBatch","batchData","batches","batch","updateState","BATCH_ABORT","bi"],"mappings":"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","sourcesContent":["import { BATCH_STATES, FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { triggerUploaderBatchEvent, getBatchFromState, getIsBatchFinalized } from \"./batchHelpers\";\nimport processFinishedRequest from \"./processFinishedRequest\";\n\nconst abortNonUploadingItem = (queue, item, next) => {\n  logger.debugLog(`uploader.queue: aborting ${item.state} item  - `, item); //manually finish request for item that hasnt reached the sender yet\n\n  processFinishedRequest(queue, [{\n    id: item.id,\n    info: {\n      status: 0,\n      state: FILE_STATES.ABORTED,\n      response: \"aborted\"\n    }\n  }], next);\n  return true;\n};\n\nconst ITEM_STATE_ABORTS = {\n  [FILE_STATES.UPLOADING]: (queue, item) => {\n    logger.debugLog(`uploader.queue: aborting uploading item  - `, item);\n    return queue.getState().aborts[item.id]();\n  },\n  [FILE_STATES.ADDED]: abortNonUploadingItem,\n  [FILE_STATES.PENDING]: abortNonUploadingItem\n};\n\nconst callAbortOnItem = (queue, id, next) => {\n  const state = queue.getState(),\n        item = state.items[id],\n        itemState = item === null || item === void 0 ? void 0 : item.state; //$FlowIssue[prop-missing]\n\n  return ITEM_STATE_ABORTS[itemState] ? //$FlowExpectedError[extra-arg]\n  //$FlowIssue[prop-missing]\n  ITEM_STATE_ABORTS[itemState](queue, item, next) : false;\n};\n\nconst abortAll = (queue, next) => {\n  const items = queue.getState().items;\n  Object.keys(items).forEach(id => callAbortOnItem(queue, id, next));\n  queue.trigger(UPLOADER_EVENTS.ALL_ABORT);\n};\n\nconst abortItem = (queue, id, next) => callAbortOnItem(queue, id, next);\n\nconst abortBatch = (queue, id, next) => {\n  const state = queue.getState(),\n        batchData = state.batches[id],\n        batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;\n\n  if (batch && !getIsBatchFinalized(batch)) {\n    queue.updateState(state => {\n      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;\n    });\n    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);\n    batch.items.forEach(bi => callAbortOnItem(queue, bi.id, next));\n  }\n};\n\nexport { abortAll, abortItem, abortBatch };"]},"metadata":{},"sourceType":"module"}