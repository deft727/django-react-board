{"ast":null,"code":"import addLife, { createLifePack } from \"@rpldy/life-events\";\nimport { BATCH_STATES, invariant, logger, triggerCancellable, devFreeze, merge, clone } from \"@rpldy/shared\";\nimport getProcessor from \"./processor\";\nimport { UPLOADER_EVENTS } from \"./consts\";\nimport { getMandatoryOptions, deepProxyUnwrap } from \"./utils\";\nvar EVENT_NAMES = Object.values(UPLOADER_EVENTS);\nvar EXT_OUTSIDE_ENHANCER_TIME = \"Uploady - uploader extensions can only be registered by enhancers\",\n    EXT_ALREADY_EXISTS = \"Uploady - uploader extension by this name [%s] already exists\";\nvar counter = 0;\n\nvar createUploader = function createUploader(options) {\n  counter += 1;\n  var uploaderId = \"uploader-\".concat(counter);\n  var enhancerTime = false;\n  var extensions = {};\n  logger.debugLog(\"uploady.uploader: creating new instance (\".concat(uploaderId, \")\"), {\n    options: options,\n    counter: counter\n  });\n  var uploaderOptions = getMandatoryOptions(options);\n\n  var update = function update(updateOptions) {\n    //TODO: updating concurrent and maxConcurrent means we need to update the processor - not supported yet!\n    uploaderOptions = merge({}, uploaderOptions, updateOptions); //need deep merge for destination\n\n    return uploader;\n  };\n\n  var add = function add(files, addOptions) {\n    var processOptions = merge({}, uploaderOptions, addOptions);\n\n    if (processOptions.clearPendingOnAdd) {\n      clearPending();\n    }\n\n    var batch = processor.addNewBatch(files, uploader.id, processOptions);\n    var resultP;\n\n    if (batch.items.length) {\n      resultP = processor.runCancellable(UPLOADER_EVENTS.BATCH_ADD, batch, processOptions).then(function (isCancelled) {\n        if (!isCancelled) {\n          logger.debugLog(\"uploady.uploader [\".concat(uploader.id, \"]: new items added - auto upload =\\n                        \").concat(String(processOptions.autoUpload)), batch.items);\n\n          if (processOptions.autoUpload) {\n            processor.process(batch);\n          }\n        } else {\n          batch.state = BATCH_STATES.CANCELLED;\n          triggerWithUnwrap(UPLOADER_EVENTS.BATCH_CANCEL, batch);\n        }\n      });\n    } else {\n      logger.debugLog(\"uploady.uploader: no items to add. batch \".concat(batch.id, \" is empty. check fileFilter if this isn't intended\"));\n    }\n\n    return resultP || Promise.resolve();\n  };\n\n  var clearPending = function clearPending() {\n    processor.clearPendingBatches();\n  };\n  /**\n   * process batches that weren't auto-uploaded\n   */\n\n\n  var getOptions = function getOptions() {\n    return clone(uploaderOptions);\n  };\n\n  var registerExtension = function registerExtension(name, methods) {\n    invariant(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);\n    invariant(!extensions[name], EXT_ALREADY_EXISTS, name);\n    logger.debugLog(\"uploady.uploader: registering extension: \".concat(name.toString()), methods);\n    extensions[name] = methods;\n  };\n\n  var _addLife = addLife({\n    id: uploaderId,\n    update: update,\n    add: add,\n    upload: function upload(uploadOptions) {\n      processor.processPendingBatches(uploadOptions);\n    },\n    abort: function abort(id) {\n      processor.abort(id);\n    },\n    abortBatch: function abortBatch(id) {\n      processor.abortBatch(id);\n    },\n    getOptions: getOptions,\n    clearPending: clearPending,\n    registerExtension: registerExtension,\n    getExtension: function getExtension(name) {\n      return extensions[name];\n    }\n  }, EVENT_NAMES, {\n    canAddEvents: false,\n    canRemoveEvents: false\n  }),\n      trigger = _addLife.trigger,\n      uploader = _addLife.target;\n  /**\n   * ensures that data being exposed to client-land isnt a proxy, only pojos\n   */\n\n\n  var triggerWithUnwrap = function triggerWithUnwrap(name) {\n    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      data[_key - 1] = arguments[_key];\n    }\n\n    //delays unwrap to the very last time on trigger. Will only unwrap if there are listeners\n    var lp = createLifePack(function () {\n      return data.map(deepProxyUnwrap);\n    });\n    return trigger(name, lp);\n  };\n\n  var cancellable = triggerCancellable(triggerWithUnwrap);\n\n  if (uploaderOptions.enhancer) {\n    enhancerTime = true;\n    var enhanced = uploaderOptions.enhancer(uploader, triggerWithUnwrap);\n    enhancerTime = false; //graceful handling for enhancer forgetting to return uploader\n\n    uploader = enhanced || uploader;\n  }\n\n  var processor = getProcessor(triggerWithUnwrap, cancellable, uploaderOptions, uploader.id);\n  return devFreeze(uploader);\n};\n\nexport default createUploader;","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/uploader/lib/esm/uploader.js"],"names":["addLife","createLifePack","BATCH_STATES","invariant","logger","triggerCancellable","devFreeze","merge","clone","getProcessor","UPLOADER_EVENTS","getMandatoryOptions","deepProxyUnwrap","EVENT_NAMES","Object","values","EXT_OUTSIDE_ENHANCER_TIME","EXT_ALREADY_EXISTS","counter","createUploader","options","uploaderId","enhancerTime","extensions","debugLog","uploaderOptions","update","updateOptions","uploader","add","files","addOptions","processOptions","clearPendingOnAdd","clearPending","batch","processor","addNewBatch","id","resultP","items","length","runCancellable","BATCH_ADD","then","isCancelled","String","autoUpload","process","state","CANCELLED","triggerWithUnwrap","BATCH_CANCEL","Promise","resolve","clearPendingBatches","getOptions","registerExtension","name","methods","toString","upload","uploadOptions","processPendingBatches","abort","abortBatch","getExtension","canAddEvents","canRemoveEvents","trigger","target","data","lp","map","cancellable","enhancer","enhanced"],"mappings":"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","sourcesContent":["import addLife, { createLifePack } from \"@rpldy/life-events\";\nimport { BATCH_STATES, invariant, logger, triggerCancellable, devFreeze, merge, clone } from \"@rpldy/shared\";\nimport getProcessor from \"./processor\";\nimport { UPLOADER_EVENTS } from \"./consts\";\nimport { getMandatoryOptions, deepProxyUnwrap } from \"./utils\";\nconst EVENT_NAMES = Object.values(UPLOADER_EVENTS);\nconst EXT_OUTSIDE_ENHANCER_TIME = \"Uploady - uploader extensions can only be registered by enhancers\",\n      EXT_ALREADY_EXISTS = \"Uploady - uploader extension by this name [%s] already exists\";\nlet counter = 0;\n\nconst createUploader = options => {\n  counter += 1;\n  const uploaderId = `uploader-${counter}`;\n  let enhancerTime = false;\n  const extensions = {};\n  logger.debugLog(`uploady.uploader: creating new instance (${uploaderId})`, {\n    options,\n    counter\n  });\n  let uploaderOptions = getMandatoryOptions(options);\n\n  const update = updateOptions => {\n    //TODO: updating concurrent and maxConcurrent means we need to update the processor - not supported yet!\n    uploaderOptions = merge({}, uploaderOptions, updateOptions); //need deep merge for destination\n\n    return uploader;\n  };\n\n  const add = (files, addOptions) => {\n    const processOptions = merge({}, uploaderOptions, addOptions);\n\n    if (processOptions.clearPendingOnAdd) {\n      clearPending();\n    }\n\n    const batch = processor.addNewBatch(files, uploader.id, processOptions);\n    let resultP;\n\n    if (batch.items.length) {\n      resultP = processor.runCancellable(UPLOADER_EVENTS.BATCH_ADD, batch, processOptions).then(isCancelled => {\n        if (!isCancelled) {\n          logger.debugLog(`uploady.uploader [${uploader.id}]: new items added - auto upload =\n                        ${String(processOptions.autoUpload)}`, batch.items);\n\n          if (processOptions.autoUpload) {\n            processor.process(batch);\n          }\n        } else {\n          batch.state = BATCH_STATES.CANCELLED;\n          triggerWithUnwrap(UPLOADER_EVENTS.BATCH_CANCEL, batch);\n        }\n      });\n    } else {\n      logger.debugLog(`uploady.uploader: no items to add. batch ${batch.id} is empty. check fileFilter if this isn't intended`);\n    }\n\n    return resultP || Promise.resolve();\n  };\n\n  const clearPending = () => {\n    processor.clearPendingBatches();\n  };\n  /**\n   * process batches that weren't auto-uploaded\n   */\n\n\n  const getOptions = () => {\n    return clone(uploaderOptions);\n  };\n\n  const registerExtension = (name, methods) => {\n    invariant(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);\n    invariant(!extensions[name], EXT_ALREADY_EXISTS, name);\n    logger.debugLog(`uploady.uploader: registering extension: ${name.toString()}`, methods);\n    extensions[name] = methods;\n  };\n\n  let {\n    trigger,\n    target: uploader\n  } = addLife({\n    id: uploaderId,\n    update,\n    add,\n    upload: uploadOptions => {\n      processor.processPendingBatches(uploadOptions);\n    },\n    abort: id => {\n      processor.abort(id);\n    },\n    abortBatch: id => {\n      processor.abortBatch(id);\n    },\n    getOptions,\n    clearPending,\n    registerExtension,\n    getExtension: name => {\n      return extensions[name];\n    }\n  }, EVENT_NAMES, {\n    canAddEvents: false,\n    canRemoveEvents: false\n  });\n  /**\n   * ensures that data being exposed to client-land isnt a proxy, only pojos\n   */\n\n  const triggerWithUnwrap = (name, ...data) => {\n    //delays unwrap to the very last time on trigger. Will only unwrap if there are listeners\n    const lp = createLifePack(() => data.map(deepProxyUnwrap));\n    return trigger(name, lp);\n  };\n\n  const cancellable = triggerCancellable(triggerWithUnwrap);\n\n  if (uploaderOptions.enhancer) {\n    enhancerTime = true;\n    const enhanced = uploaderOptions.enhancer(uploader, triggerWithUnwrap);\n    enhancerTime = false; //graceful handling for enhancer forgetting to return uploader\n\n    uploader = enhanced || uploader;\n  }\n\n  const processor = getProcessor(triggerWithUnwrap, cancellable, uploaderOptions, uploader.id);\n  return devFreeze(uploader);\n};\n\nexport default createUploader;"]},"metadata":{},"sourceType":"module"}