{"ast":null,"code":"import isPlainObject from \"./isPlainObject\";\nexport var isMergeObj = function isMergeObj(obj) {\n  return isPlainObject(obj) || Array.isArray(obj);\n};\n\nvar getKeys = function getKeys(obj, options) {\n  var keys = Object.keys(obj);\n  return options.withSymbols ? keys.concat(Object.getOwnPropertySymbols(obj)) : keys;\n};\n\nvar getMerge = function getMerge() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var merge = function merge(target) {\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n\n    if (target && sources.length) {\n      sources.forEach(function (source) {\n        if (source) {\n          getKeys(source, options).forEach(function (key) {\n            var prop = source[key];\n\n            if (!options.predicate || options.predicate(key, prop)) {\n              if (typeof prop !== \"undefined\" || options.undefinedOverwrites) {\n                //object/array - go deeper\n                if (isMergeObj(prop)) {\n                  if (typeof target[key] === \"undefined\" || !isPlainObject(target[key])) {\n                    //recreate target prop if doesnt exist or not an object\n                    target[key] = Array.isArray(prop) ? [] : {};\n                  }\n\n                  merge(target[key], prop);\n                } else {\n                  target[key] = prop;\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n\n    return target;\n  };\n\n  return merge;\n};\n/**\n * Does deep merge of simple objects and arrays (only)\n *\n * The first parameter is the target\n * Will only merge objects passed as arguments to this method\n * Any property in a later object will simply override the one in a previous one\n * Undefined properties from sources will be ignored\n *\n * No recursion protection\n */\n\n\nexport default getMerge();\nexport { getMerge };","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/shared/lib/esm/utils/merge.js"],"names":["isPlainObject","isMergeObj","obj","Array","isArray","getKeys","options","keys","Object","withSymbols","concat","getOwnPropertySymbols","getMerge","merge","target","sources","length","forEach","source","key","prop","predicate","undefinedOverwrites"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAAAC,GAAG;AAAA,SAAIF,aAAa,CAACE,GAAD,CAAb,IAAsBC,KAAK,CAACC,OAAN,CAAcF,GAAd,CAA1B;AAAA,CAAtB;;AAEP,IAAMG,OAAO,GAAG,SAAVA,OAAU,CAACH,GAAD,EAAMI,OAAN,EAAkB;AAChC,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYL,GAAZ,CAAb;AACA,SAAOI,OAAO,CAACG,WAAR,GAAsBF,IAAI,CAACG,MAAL,CAAYF,MAAM,CAACG,qBAAP,CAA6BT,GAA7B,CAAZ,CAAtB,GAAuEK,IAA9E;AACD,CAHD;;AAKA,IAAMK,QAAQ,GAAG,SAAXA,QAAW,GAAkB;AAAA,MAAjBN,OAAiB,uEAAP,EAAO;;AACjC,MAAMO,KAAK,GAAG,SAARA,KAAQ,CAACC,MAAD,EAAwB;AAAA,sCAAZC,OAAY;AAAZA,MAAAA,OAAY;AAAA;;AACpC,QAAID,MAAM,IAAIC,OAAO,CAACC,MAAtB,EAA8B;AAC5BD,MAAAA,OAAO,CAACE,OAAR,CAAgB,UAAAC,MAAM,EAAI;AACxB,YAAIA,MAAJ,EAAY;AACVb,UAAAA,OAAO,CAACa,MAAD,EAASZ,OAAT,CAAP,CAAyBW,OAAzB,CAAiC,UAAAE,GAAG,EAAI;AACtC,gBAAMC,IAAI,GAAGF,MAAM,CAACC,GAAD,CAAnB;;AAEA,gBAAI,CAACb,OAAO,CAACe,SAAT,IAAsBf,OAAO,CAACe,SAAR,CAAkBF,GAAlB,EAAuBC,IAAvB,CAA1B,EAAwD;AACtD,kBAAI,OAAOA,IAAP,KAAgB,WAAhB,IAA+Bd,OAAO,CAACgB,mBAA3C,EAAgE;AAC9D;AACA,oBAAIrB,UAAU,CAACmB,IAAD,CAAd,EAAsB;AACpB,sBAAI,OAAON,MAAM,CAACK,GAAD,CAAb,KAAuB,WAAvB,IAAsC,CAACnB,aAAa,CAACc,MAAM,CAACK,GAAD,CAAP,CAAxD,EAAuE;AACrE;AACAL,oBAAAA,MAAM,CAACK,GAAD,CAAN,GAAchB,KAAK,CAACC,OAAN,CAAcgB,IAAd,IAAsB,EAAtB,GAA2B,EAAzC;AACD;;AAEDP,kBAAAA,KAAK,CAACC,MAAM,CAACK,GAAD,CAAP,EAAcC,IAAd,CAAL;AACD,iBAPD,MAOO;AACLN,kBAAAA,MAAM,CAACK,GAAD,CAAN,GAAcC,IAAd;AACD;AACF;AACF;AACF,WAlBD;AAmBD;AACF,OAtBD;AAuBD;;AAED,WAAON,MAAP;AACD,GA5BD;;AA8BA,SAAOD,KAAP;AACD,CAhCD;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,eAAeD,QAAQ,EAAvB;AACA,SAASA,QAAT","sourcesContent":["import isPlainObject from \"./isPlainObject\";\nexport const isMergeObj = obj => isPlainObject(obj) || Array.isArray(obj);\n\nconst getKeys = (obj, options) => {\n  const keys = Object.keys(obj);\n  return options.withSymbols ? keys.concat(Object.getOwnPropertySymbols(obj)) : keys;\n};\n\nconst getMerge = (options = {}) => {\n  const merge = (target, ...sources) => {\n    if (target && sources.length) {\n      sources.forEach(source => {\n        if (source) {\n          getKeys(source, options).forEach(key => {\n            const prop = source[key];\n\n            if (!options.predicate || options.predicate(key, prop)) {\n              if (typeof prop !== \"undefined\" || options.undefinedOverwrites) {\n                //object/array - go deeper\n                if (isMergeObj(prop)) {\n                  if (typeof target[key] === \"undefined\" || !isPlainObject(target[key])) {\n                    //recreate target prop if doesnt exist or not an object\n                    target[key] = Array.isArray(prop) ? [] : {};\n                  }\n\n                  merge(target[key], prop);\n                } else {\n                  target[key] = prop;\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n\n    return target;\n  };\n\n  return merge;\n};\n/**\n * Does deep merge of simple objects and arrays (only)\n *\n * The first parameter is the target\n * Will only merge objects passed as arguments to this method\n * Any property in a later object will simply override the one in a previous one\n * Undefined properties from sources will be ignored\n *\n * No recursion protection\n */\n\n\nexport default getMerge();\nexport { getMerge };"]},"metadata":{},"sourceType":"module"}