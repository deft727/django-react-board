{"ast":null,"code":"import _defineProperty from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _FILE_STATE_TO_EVENT_;\n\nimport { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS, ITEM_FINALIZE_STATES } from \"../consts\";\nimport { cleanUpFinishedBatches, incrementBatchFinishedCounter } from \"./batchHelpers\";\nexport var FILE_STATE_TO_EVENT_MAP = (_FILE_STATE_TO_EVENT_ = {}, _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.PENDING, null), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ADDED, UPLOADER_EVENTS.ITEM_START), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.FINISHED, UPLOADER_EVENTS.ITEM_FINISH), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ERROR, UPLOADER_EVENTS.ITEM_ERROR), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.CANCELLED, UPLOADER_EVENTS.ITEM_CANCEL), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ABORTED, UPLOADER_EVENTS.ITEM_ABORT), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.UPLOADING, UPLOADER_EVENTS.ITEM_PROGRESS), _FILE_STATE_TO_EVENT_);\n\nvar getIsFinalized = function getIsFinalized(item) {\n  return !!~ITEM_FINALIZE_STATES.indexOf(item.state);\n};\n\nvar processFinishedRequest = function processFinishedRequest(queue, finishedData, next) {\n  finishedData.forEach(function (itemData) {\n    var state = queue.getState();\n    var id = itemData.id,\n        info = itemData.info;\n    logger.debugLog(\"uploader.processor.queue: request finished for item - \", {\n      id: id,\n      info: info\n    });\n\n    if (state.items[id]) {\n      queue.updateState(function (state) {\n        var item = state.items[id];\n        item.state = info.state;\n        item.uploadResponse = info.response;\n        item.uploadStatus = info.status;\n\n        if (getIsFinalized(item)) {\n          delete state.aborts[id];\n        }\n      }); //get most up-to-date item data\n\n      var item = queue.getState().items[id];\n\n      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {\n        //ensure we trigger progress event with completed = 100 for all items\n        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);\n      }\n\n      if (FILE_STATE_TO_EVENT_MAP[item.state]) {\n        //trigger UPLOADER EVENT for item based on its state\n        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);\n      }\n\n      if (getIsFinalized(item)) {\n        incrementBatchFinishedCounter(queue, item.batchId); //trigger FINALIZE event\n\n        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);\n      }\n    }\n\n    var index = state.itemQueue.indexOf(id);\n\n    if (~index) {\n      queue.updateState(function (state) {\n        state.itemQueue.splice(index, 1);\n        var activeIndex = state.activeIds.indexOf(id);\n\n        if (~activeIndex) {\n          state.activeIds.splice(activeIndex, 1);\n        }\n      });\n    }\n  }); //ensure finished batches are remove from state\n\n  cleanUpFinishedBatches(queue);\n  return next(queue);\n};\n\nexport default processFinishedRequest;","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/uploader/lib/esm/queue/processFinishedRequest.js"],"names":["FILE_STATES","logger","UPLOADER_EVENTS","ITEM_FINALIZE_STATES","cleanUpFinishedBatches","incrementBatchFinishedCounter","FILE_STATE_TO_EVENT_MAP","PENDING","ADDED","ITEM_START","FINISHED","ITEM_FINISH","ERROR","ITEM_ERROR","CANCELLED","ITEM_CANCEL","ABORTED","ITEM_ABORT","UPLOADING","ITEM_PROGRESS","getIsFinalized","item","indexOf","state","processFinishedRequest","queue","finishedData","next","forEach","itemData","getState","id","info","debugLog","items","updateState","uploadResponse","response","uploadStatus","status","aborts","completed","handleItemProgress","file","size","trigger","batchId","ITEM_FINALIZE","index","itemQueue","splice","activeIndex","activeIds"],"mappings":"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","sourcesContent":["import { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS, ITEM_FINALIZE_STATES } from \"../consts\";\nimport { cleanUpFinishedBatches, incrementBatchFinishedCounter } from \"./batchHelpers\";\nexport const FILE_STATE_TO_EVENT_MAP = {\n  [FILE_STATES.PENDING]: null,\n  [FILE_STATES.ADDED]: UPLOADER_EVENTS.ITEM_START,\n  [FILE_STATES.FINISHED]: UPLOADER_EVENTS.ITEM_FINISH,\n  [FILE_STATES.ERROR]: UPLOADER_EVENTS.ITEM_ERROR,\n  [FILE_STATES.CANCELLED]: UPLOADER_EVENTS.ITEM_CANCEL,\n  [FILE_STATES.ABORTED]: UPLOADER_EVENTS.ITEM_ABORT,\n  [FILE_STATES.UPLOADING]: UPLOADER_EVENTS.ITEM_PROGRESS\n};\n\nconst getIsFinalized = item => !!~ITEM_FINALIZE_STATES.indexOf(item.state);\n\nconst processFinishedRequest = (queue, finishedData, next) => {\n  finishedData.forEach(itemData => {\n    const state = queue.getState();\n    const {\n      id,\n      info\n    } = itemData;\n    logger.debugLog(\"uploader.processor.queue: request finished for item - \", {\n      id,\n      info\n    });\n\n    if (state.items[id]) {\n      queue.updateState(state => {\n        const item = state.items[id];\n        item.state = info.state;\n        item.uploadResponse = info.response;\n        item.uploadStatus = info.status;\n\n        if (getIsFinalized(item)) {\n          delete state.aborts[id];\n        }\n      }); //get most up-to-date item data\n\n      const item = queue.getState().items[id];\n\n      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {\n        //ensure we trigger progress event with completed = 100 for all items\n        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);\n      }\n\n      if (FILE_STATE_TO_EVENT_MAP[item.state]) {\n        //trigger UPLOADER EVENT for item based on its state\n        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);\n      }\n\n      if (getIsFinalized(item)) {\n        incrementBatchFinishedCounter(queue, item.batchId); //trigger FINALIZE event\n\n        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);\n      }\n    }\n\n    const index = state.itemQueue.indexOf(id);\n\n    if (~index) {\n      queue.updateState(state => {\n        state.itemQueue.splice(index, 1);\n        const activeIndex = state.activeIds.indexOf(id);\n\n        if (~activeIndex) {\n          state.activeIds.splice(activeIndex, 1);\n        }\n      });\n    }\n  }); //ensure finished batches are remove from state\n\n  cleanUpFinishedBatches(queue);\n  return next(queue);\n};\n\nexport default processFinishedRequest;"]},"metadata":{},"sourceType":"module"}