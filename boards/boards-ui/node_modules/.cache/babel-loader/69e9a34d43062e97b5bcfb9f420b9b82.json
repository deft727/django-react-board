{"ast":null,"code":"import _defineProperty from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport isPromise from \"is-promise\";\nimport defaults from \"./defaults\";\nimport { validateFunction, isUndefined } from \"./utils\";\nimport { LESYM, LE_PACK_SYM } from \"./consts\"; //TODO: implement STATS\n\nvar getLE = function getLE(obj) {\n  return obj ? obj[LESYM] : null;\n};\n\nvar getValidLE = function getValidLE(obj) {\n  var le = getLE(obj);\n\n  if (!le) {\n    throw new Error(\"Didnt find LE internal object. Something very bad happened!\");\n  }\n\n  return le;\n};\n\nvar isLE = function isLE(obj) {\n  return !!getLE(obj);\n};\n\nvar addRegistration = function addRegistration(obj, name, cb) {\n  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  validateFunction(cb, \"cb\");\n  var le = getValidLE(obj);\n\n  if (!le.options.allowRegisterNonExistent && !~le.events.indexOf(name)) {\n    throw new Error(\"Cannot register for event \".concat(name.toString(), \" that wasn't already defined (allowRegisterNonExistent = false)\"));\n  }\n\n  var namedRegistry = le.registry[name] || [];\n\n  if (!namedRegistry.find(function (r) {\n    return r.cb === cb;\n  })) {\n    //only add same callback for a name once\n    namedRegistry.push({\n      name: name,\n      cb: cb,\n      once: once\n    });\n    le.registry[name] = namedRegistry;\n  }\n\n  return function () {\n    return unregister.call(obj, name, cb);\n  };\n};\n\nvar findRegistrations = function findRegistrations(obj, name) {\n  var registry = getValidLE(obj).registry;\n  return name ? registry[name] ? registry[name].slice() : [] : // $FlowFixMe - flow doesnt know about Array.prototype.flat yet...\n  Object.values(registry).flat();\n};\n\nvar publicMethods = {\n  \"on\": register,\n  \"once\": registerOnce,\n  \"off\": unregister,\n  \"getEvents\": getEvents\n};\n\nvar getPublicMethods = function getPublicMethods() {\n  return Object.entries(publicMethods).reduce(function (res, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        m = _ref2[1];\n\n    res[key] = {\n      value: m\n    };\n    return res;\n  }, {});\n}; //using string keys here because can't rely on function names to stay after (babel/webpack) build\n\n\nvar apiMethods = {\n  \"trigger\": trigger,\n  \"addEvent\": addEvent,\n  \"removeEvent\": removeEvent,\n  \"hasEvent\": hasEvent,\n  \"hasEventRegistrations\": hasEventRegistrations,\n  \"assign\": assign\n};\n\nvar createApi = function createApi(target) {\n  return Object.keys(apiMethods).reduce(function (res, name) {\n    res[name] = apiMethods[name].bind(target);\n    return res;\n  }, _objectSpread({\n    target: target\n  }, apiMethods));\n};\n\nvar cleanRegistryForName = function cleanRegistryForName(obj, name) {\n  var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var registry = getValidLE(obj).registry;\n\n  if (registry[name] && (force || !registry[name].length)) {\n    delete registry[name];\n  }\n};\n\nvar removeRegItem = function removeRegItem(obj, name, cb) {\n  var registry = getValidLE(obj).registry;\n\n  if (registry[name]) {\n    if (!cb) {\n      cleanRegistryForName(obj, name, true);\n    } else {\n      registry[name] = registry[name].filter(function (reg) {\n        return reg.cb !== cb;\n      });\n      cleanRegistryForName(obj, name);\n    }\n  }\n};\n\nfunction register(name, cb) {\n  return addRegistration(this, name, cb);\n}\n\nfunction registerOnce(name, cb) {\n  return addRegistration(this, name, cb, true);\n}\n\nfunction unregister(name, cb) {\n  removeRegItem(this, name, cb);\n}\n\nfunction getEvents() {\n  return getValidLE(this).events.slice();\n}\n\nfunction trigger(name) {\n  var _this = this;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var regs = findRegistrations(this, name);\n  var results;\n\n  if (regs.length) {\n    var _args$;\n\n    var packValue;\n\n    if (args.length === 1 && ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$[LE_PACK_SYM]) === true) {\n      //life-pack always returns array as params to spread\n      packValue = args[0].resolve();\n    }\n\n    results = regs.map(function (r) {\n      var result;\n\n      if (r.once) {\n        removeRegItem(_this, name, r.cb);\n      }\n\n      if (packValue) {\n        result = r.cb.apply(r, _toConsumableArray(packValue));\n      } else if (!args.length) {\n        result = r.cb();\n      } else if (args.length === 1) {\n        result = r.cb(args[0]);\n      } else if (args.length === 2) {\n        result = r.cb(args[0], args[1]);\n      } else if (args.length === 3) {\n        result = r.cb(args[0], args[1], args[2]);\n      } else {\n        result = r.cb.apply(r, args);\n      }\n\n      return result;\n    }).filter(function (result) {\n      return !isUndefined(result);\n    }).map(function (result) {\n      return isPromise(result) ? result : Promise.resolve(result);\n    });\n  }\n\n  return results && (results.length ? results : undefined);\n} //registry, events, stats become shared\n\n\nfunction assign(toObj) {\n  var le = getValidLE(this);\n  defineLifeData(toObj, le.options, le.events, le.registry, le.stats);\n  return createApi(toObj);\n}\n\nfunction addEvent(name) {\n  var le = getValidLE(this);\n\n  if (le.options.canAddEvents) {\n    var index = le.events.indexOf(name);\n\n    if (!~index) {\n      le.events.push(name);\n    } else {\n      throw new Error(\"Event '\".concat(name, \"' already defined\"));\n    }\n  } else {\n    throw new Error(\"Cannot add new events (canAddEvents = false)\");\n  }\n}\n\nfunction removeEvent(name) {\n  var le = getValidLE(this);\n\n  if (le.options.canRemoveEvents) {\n    var index = le.events.indexOf(name);\n    le.events.splice(index, 1);\n  } else {\n    throw new Error(\"Cannot remove events (canRemoveEvents = false)\");\n  }\n}\n\nfunction hasEvent(name) {\n  var le = getValidLE(this);\n  return !!~le.events.indexOf(name);\n}\n\nfunction hasEventRegistrations(name) {\n  return !!findRegistrations(this, name).length;\n} // function getStats(name?: any) {\n//\n// }\n\n\nvar defineLifeData = function defineLifeData(target, options) {\n  var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var registry = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var stats = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  Object.defineProperties(target, _objectSpread(_defineProperty({}, LESYM, {\n    value: Object.seal({\n      registry: registry,\n      events: events,\n      options: options,\n      stats: stats\n    })\n  }), getPublicMethods()));\n};\n\nvar addLife = function addLife(target) {\n  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  target = target || {};\n  options = _objectSpread(_objectSpread({}, defaults), options);\n\n  if (!isLE(target)) {\n    defineLifeData(target, options, events);\n  }\n\n  return createApi(target);\n};\n\nexport default addLife;\nexport { isLE };","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/life-events/lib/esm/lifeEvents.js"],"names":["isPromise","defaults","validateFunction","isUndefined","LESYM","LE_PACK_SYM","getLE","obj","getValidLE","le","Error","isLE","addRegistration","name","cb","once","options","allowRegisterNonExistent","events","indexOf","toString","namedRegistry","registry","find","r","push","unregister","call","findRegistrations","slice","Object","values","flat","publicMethods","register","registerOnce","getEvents","getPublicMethods","entries","reduce","res","key","m","value","apiMethods","trigger","addEvent","removeEvent","hasEvent","hasEventRegistrations","assign","createApi","target","keys","bind","cleanRegistryForName","force","length","removeRegItem","filter","reg","args","regs","results","_args$","packValue","resolve","map","result","Promise","undefined","toObj","defineLifeData","stats","canAddEvents","index","canRemoveEvents","splice","defineProperties","seal","addLife"],"mappings":";;;;AAAA,OAAOA,SAAP,MAAsB,YAAtB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,SAASC,gBAAT,EAA2BC,WAA3B,QAA8C,SAA9C;AACA,SAASC,KAAT,EAAgBC,WAAhB,QAAmC,UAAnC,C,CAEA;;AACA,IAAMC,KAAK,GAAG,SAARA,KAAQ,CAAAC,GAAG;AAAA,SAAIA,GAAG,GAAGA,GAAG,CAACH,KAAD,CAAN,GAAgB,IAAvB;AAAA,CAAjB;;AAEA,IAAMI,UAAU,GAAG,SAAbA,UAAa,CAAAD,GAAG,EAAI;AACxB,MAAME,EAAE,GAAGH,KAAK,CAACC,GAAD,CAAhB;;AAEA,MAAI,CAACE,EAAL,EAAS;AACP,UAAM,IAAIC,KAAJ,CAAU,6DAAV,CAAN;AACD;;AAED,SAAOD,EAAP;AACD,CARD;;AAUA,IAAME,IAAI,GAAG,SAAPA,IAAO,CAAAJ,GAAG;AAAA,SAAI,CAAC,CAACD,KAAK,CAACC,GAAD,CAAX;AAAA,CAAhB;;AAEA,IAAMK,eAAe,GAAG,SAAlBA,eAAkB,CAACL,GAAD,EAAMM,IAAN,EAAYC,EAAZ,EAAiC;AAAA,MAAjBC,IAAiB,uEAAV,KAAU;AACvDb,EAAAA,gBAAgB,CAACY,EAAD,EAAK,IAAL,CAAhB;AACA,MAAML,EAAE,GAAGD,UAAU,CAACD,GAAD,CAArB;;AAEA,MAAI,CAACE,EAAE,CAACO,OAAH,CAAWC,wBAAZ,IAAwC,CAAC,CAACR,EAAE,CAACS,MAAH,CAAUC,OAAV,CAAkBN,IAAlB,CAA9C,EAAuE;AACrE,UAAM,IAAIH,KAAJ,qCAAuCG,IAAI,CAACO,QAAL,EAAvC,qEAAN;AACD;;AAED,MAAMC,aAAa,GAAGZ,EAAE,CAACa,QAAH,CAAYT,IAAZ,KAAqB,EAA3C;;AAEA,MAAI,CAACQ,aAAa,CAACE,IAAd,CAAmB,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACV,EAAF,KAASA,EAAb;AAAA,GAApB,CAAL,EAA2C;AACzC;AACAO,IAAAA,aAAa,CAACI,IAAd,CAAmB;AACjBZ,MAAAA,IAAI,EAAJA,IADiB;AAEjBC,MAAAA,EAAE,EAAFA,EAFiB;AAGjBC,MAAAA,IAAI,EAAJA;AAHiB,KAAnB;AAKAN,IAAAA,EAAE,CAACa,QAAH,CAAYT,IAAZ,IAAoBQ,aAApB;AACD;;AAED,SAAO;AAAA,WAAMK,UAAU,CAACC,IAAX,CAAgBpB,GAAhB,EAAqBM,IAArB,EAA2BC,EAA3B,CAAN;AAAA,GAAP;AACD,CArBD;;AAuBA,IAAMc,iBAAiB,GAAG,SAApBA,iBAAoB,CAACrB,GAAD,EAAMM,IAAN,EAAe;AACvC,MAAMS,QAAQ,GAAGd,UAAU,CAACD,GAAD,CAAV,CAAgBe,QAAjC;AACA,SAAOT,IAAI,GAAGS,QAAQ,CAACT,IAAD,CAAR,GAAiBS,QAAQ,CAACT,IAAD,CAAR,CAAegB,KAAf,EAAjB,GAA0C,EAA7C,GAAkD;AAC7DC,EAAAA,MAAM,CAACC,MAAP,CAAcT,QAAd,EAAwBU,IAAxB,EADA;AAED,CAJD;;AAMA,IAAMC,aAAa,GAAG;AACpB,QAAMC,QADc;AAEpB,UAAQC,YAFY;AAGpB,SAAOT,UAHa;AAIpB,eAAaU;AAJO,CAAtB;;AAOA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB;AAAA,SAAMP,MAAM,CAACQ,OAAP,CAAeL,aAAf,EAA8BM,MAA9B,CAAqC,UAACC,GAAD,QAAmB;AAAA;AAAA,QAAZC,GAAY;AAAA,QAAPC,CAAO;;AACrFF,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAW;AACTE,MAAAA,KAAK,EAAED;AADE,KAAX;AAGA,WAAOF,GAAP;AACD,GAL8B,EAK5B,EAL4B,CAAN;AAAA,CAAzB,C,CAKQ;;;AAGR,IAAMI,UAAU,GAAG;AACjB,aAAWC,OADM;AAEjB,cAAYC,QAFK;AAGjB,iBAAeC,WAHE;AAIjB,cAAYC,QAJK;AAKjB,2BAAyBC,qBALR;AAMjB,YAAUC;AANO,CAAnB;;AASA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAAAC,MAAM;AAAA,SAAItB,MAAM,CAACuB,IAAP,CAAYT,UAAZ,EAAwBL,MAAxB,CAA+B,UAACC,GAAD,EAAM3B,IAAN,EAAe;AACxE2B,IAAAA,GAAG,CAAC3B,IAAD,CAAH,GAAY+B,UAAU,CAAC/B,IAAD,CAAV,CAAiByC,IAAjB,CAAsBF,MAAtB,CAAZ;AACA,WAAOZ,GAAP;AACD,GAH2B;AAI1BY,IAAAA,MAAM,EAANA;AAJ0B,KAKvBR,UALuB,EAAJ;AAAA,CAAxB;;AAQA,IAAMW,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAChD,GAAD,EAAMM,IAAN,EAA8B;AAAA,MAAlB2C,KAAkB,uEAAV,KAAU;AACzD,MAAMlC,QAAQ,GAAGd,UAAU,CAACD,GAAD,CAAV,CAAgBe,QAAjC;;AAEA,MAAIA,QAAQ,CAACT,IAAD,CAAR,KAAmB2C,KAAK,IAAI,CAAClC,QAAQ,CAACT,IAAD,CAAR,CAAe4C,MAA5C,CAAJ,EAAyD;AACvD,WAAOnC,QAAQ,CAACT,IAAD,CAAf;AACD;AACF,CAND;;AAQA,IAAM6C,aAAa,GAAG,SAAhBA,aAAgB,CAACnD,GAAD,EAAMM,IAAN,EAAYC,EAAZ,EAAmB;AACvC,MAAMQ,QAAQ,GAAGd,UAAU,CAACD,GAAD,CAAV,CAAgBe,QAAjC;;AAEA,MAAIA,QAAQ,CAACT,IAAD,CAAZ,EAAoB;AAClB,QAAI,CAACC,EAAL,EAAS;AACPyC,MAAAA,oBAAoB,CAAChD,GAAD,EAAMM,IAAN,EAAY,IAAZ,CAApB;AACD,KAFD,MAEO;AACLS,MAAAA,QAAQ,CAACT,IAAD,CAAR,GAAiBS,QAAQ,CAACT,IAAD,CAAR,CAAe8C,MAAf,CAAsB,UAAAC,GAAG;AAAA,eAAIA,GAAG,CAAC9C,EAAJ,KAAWA,EAAf;AAAA,OAAzB,CAAjB;AACAyC,MAAAA,oBAAoB,CAAChD,GAAD,EAAMM,IAAN,CAApB;AACD;AACF;AACF,CAXD;;AAaA,SAASqB,QAAT,CAAkBrB,IAAlB,EAAwBC,EAAxB,EAA4B;AAC1B,SAAOF,eAAe,CAAC,IAAD,EAAOC,IAAP,EAAaC,EAAb,CAAtB;AACD;;AAED,SAASqB,YAAT,CAAsBtB,IAAtB,EAA4BC,EAA5B,EAAgC;AAC9B,SAAOF,eAAe,CAAC,IAAD,EAAOC,IAAP,EAAaC,EAAb,EAAiB,IAAjB,CAAtB;AACD;;AAED,SAASY,UAAT,CAAoBb,IAApB,EAA0BC,EAA1B,EAA8B;AAC5B4C,EAAAA,aAAa,CAAC,IAAD,EAAO7C,IAAP,EAAaC,EAAb,CAAb;AACD;;AAED,SAASsB,SAAT,GAAqB;AACnB,SAAO5B,UAAU,CAAC,IAAD,CAAV,CAAiBU,MAAjB,CAAwBW,KAAxB,EAAP;AACD;;AAED,SAASgB,OAAT,CAAiBhC,IAAjB,EAAgC;AAAA;;AAAA,oCAANgD,IAAM;AAANA,IAAAA,IAAM;AAAA;;AAC9B,MAAMC,IAAI,GAAGlC,iBAAiB,CAAC,IAAD,EAAOf,IAAP,CAA9B;AACA,MAAIkD,OAAJ;;AAEA,MAAID,IAAI,CAACL,MAAT,EAAiB;AACf,QAAIO,MAAJ;;AAEA,QAAIC,SAAJ;;AAEA,QAAIJ,IAAI,CAACJ,MAAL,KAAgB,CAAhB,IAAqB,CAAC,CAACO,MAAM,GAAGH,IAAI,CAAC,CAAD,CAAd,MAAuB,IAAvB,IAA+BG,MAAM,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,MAAM,CAAC3D,WAAD,CAAnE,MAAsF,IAA/G,EAAqH;AACnH;AACA4D,MAAAA,SAAS,GAAGJ,IAAI,CAAC,CAAD,CAAJ,CAAQK,OAAR,EAAZ;AACD;;AAEDH,IAAAA,OAAO,GAAGD,IAAI,CAACK,GAAL,CAAS,UAAA3C,CAAC,EAAI;AACtB,UAAI4C,MAAJ;;AAEA,UAAI5C,CAAC,CAACT,IAAN,EAAY;AACV2C,QAAAA,aAAa,CAAC,KAAD,EAAO7C,IAAP,EAAaW,CAAC,CAACV,EAAf,CAAb;AACD;;AAED,UAAImD,SAAJ,EAAe;AACbG,QAAAA,MAAM,GAAG5C,CAAC,CAACV,EAAF,OAAAU,CAAC,qBAAOyC,SAAP,EAAV;AACD,OAFD,MAEO,IAAI,CAACJ,IAAI,CAACJ,MAAV,EAAkB;AACvBW,QAAAA,MAAM,GAAG5C,CAAC,CAACV,EAAF,EAAT;AACD,OAFM,MAEA,IAAI+C,IAAI,CAACJ,MAAL,KAAgB,CAApB,EAAuB;AAC5BW,QAAAA,MAAM,GAAG5C,CAAC,CAACV,EAAF,CAAK+C,IAAI,CAAC,CAAD,CAAT,CAAT;AACD,OAFM,MAEA,IAAIA,IAAI,CAACJ,MAAL,KAAgB,CAApB,EAAuB;AAC5BW,QAAAA,MAAM,GAAG5C,CAAC,CAACV,EAAF,CAAK+C,IAAI,CAAC,CAAD,CAAT,EAAcA,IAAI,CAAC,CAAD,CAAlB,CAAT;AACD,OAFM,MAEA,IAAIA,IAAI,CAACJ,MAAL,KAAgB,CAApB,EAAuB;AAC5BW,QAAAA,MAAM,GAAG5C,CAAC,CAACV,EAAF,CAAK+C,IAAI,CAAC,CAAD,CAAT,EAAcA,IAAI,CAAC,CAAD,CAAlB,EAAuBA,IAAI,CAAC,CAAD,CAA3B,CAAT;AACD,OAFM,MAEA;AACLO,QAAAA,MAAM,GAAG5C,CAAC,CAACV,EAAF,OAAAU,CAAC,EAAOqC,IAAP,CAAV;AACD;;AAED,aAAOO,MAAP;AACD,KAtBS,EAsBPT,MAtBO,CAsBA,UAAAS,MAAM;AAAA,aAAI,CAACjE,WAAW,CAACiE,MAAD,CAAhB;AAAA,KAtBN,EAsBgCD,GAtBhC,CAsBoC,UAAAC,MAAM;AAAA,aAAIpE,SAAS,CAACoE,MAAD,CAAT,GAAoBA,MAApB,GAA6BC,OAAO,CAACH,OAAR,CAAgBE,MAAhB,CAAjC;AAAA,KAtB1C,CAAV;AAuBD;;AAED,SAAOL,OAAO,KAAKA,OAAO,CAACN,MAAR,GAAiBM,OAAjB,GAA2BO,SAAhC,CAAd;AACD,C,CAAC;;;AAGF,SAASpB,MAAT,CAAgBqB,KAAhB,EAAuB;AACrB,MAAM9D,EAAE,GAAGD,UAAU,CAAC,IAAD,CAArB;AACAgE,EAAAA,cAAc,CAACD,KAAD,EAAQ9D,EAAE,CAACO,OAAX,EAAoBP,EAAE,CAACS,MAAvB,EAA+BT,EAAE,CAACa,QAAlC,EAA4Cb,EAAE,CAACgE,KAA/C,CAAd;AACA,SAAOtB,SAAS,CAACoB,KAAD,CAAhB;AACD;;AAED,SAASzB,QAAT,CAAkBjC,IAAlB,EAAwB;AACtB,MAAMJ,EAAE,GAAGD,UAAU,CAAC,IAAD,CAArB;;AAEA,MAAIC,EAAE,CAACO,OAAH,CAAW0D,YAAf,EAA6B;AAC3B,QAAMC,KAAK,GAAGlE,EAAE,CAACS,MAAH,CAAUC,OAAV,CAAkBN,IAAlB,CAAd;;AAEA,QAAI,CAAC,CAAC8D,KAAN,EAAa;AACXlE,MAAAA,EAAE,CAACS,MAAH,CAAUO,IAAV,CAAeZ,IAAf;AACD,KAFD,MAEO;AACL,YAAM,IAAIH,KAAJ,kBAAoBG,IAApB,uBAAN;AACD;AACF,GARD,MAQO;AACL,UAAM,IAAIH,KAAJ,CAAU,8CAAV,CAAN;AACD;AACF;;AAED,SAASqC,WAAT,CAAqBlC,IAArB,EAA2B;AACzB,MAAMJ,EAAE,GAAGD,UAAU,CAAC,IAAD,CAArB;;AAEA,MAAIC,EAAE,CAACO,OAAH,CAAW4D,eAAf,EAAgC;AAC9B,QAAMD,KAAK,GAAGlE,EAAE,CAACS,MAAH,CAAUC,OAAV,CAAkBN,IAAlB,CAAd;AACAJ,IAAAA,EAAE,CAACS,MAAH,CAAU2D,MAAV,CAAiBF,KAAjB,EAAwB,CAAxB;AACD,GAHD,MAGO;AACL,UAAM,IAAIjE,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF;;AAED,SAASsC,QAAT,CAAkBnC,IAAlB,EAAwB;AACtB,MAAMJ,EAAE,GAAGD,UAAU,CAAC,IAAD,CAArB;AACA,SAAO,CAAC,CAAC,CAACC,EAAE,CAACS,MAAH,CAAUC,OAAV,CAAkBN,IAAlB,CAAV;AACD;;AAED,SAASoC,qBAAT,CAA+BpC,IAA/B,EAAqC;AACnC,SAAO,CAAC,CAACe,iBAAiB,CAAC,IAAD,EAAOf,IAAP,CAAjB,CAA8B4C,MAAvC;AACD,C,CAAC;AACF;AACA;;;AAGA,IAAMe,cAAc,GAAG,SAAjBA,cAAiB,CAACpB,MAAD,EAASpC,OAAT,EAA6D;AAAA,MAA3CE,MAA2C,uEAAlC,EAAkC;AAAA,MAA9BI,QAA8B,uEAAnB,EAAmB;AAAA,MAAfmD,KAAe,uEAAP,EAAO;AAClF3C,EAAAA,MAAM,CAACgD,gBAAP,CAAwB1B,MAAxB,oCACGhD,KADH,EACW;AACPuC,IAAAA,KAAK,EAAEb,MAAM,CAACiD,IAAP,CAAY;AACjBzD,MAAAA,QAAQ,EAARA,QADiB;AAEjBJ,MAAAA,MAAM,EAANA,MAFiB;AAGjBF,MAAAA,OAAO,EAAPA,OAHiB;AAIjByD,MAAAA,KAAK,EAALA;AAJiB,KAAZ;AADA,GADX,GASKpC,gBAAgB,EATrB;AAWD,CAZD;;AAcA,IAAM2C,OAAO,GAAG,SAAVA,OAAU,CAAC5B,MAAD,EAAkC;AAAA,MAAzBlC,MAAyB,uEAAhB,EAAgB;AAAA,MAAZF,OAAY;AAChDoC,EAAAA,MAAM,GAAGA,MAAM,IAAI,EAAnB;AACApC,EAAAA,OAAO,mCAAQf,QAAR,GACFe,OADE,CAAP;;AAIA,MAAI,CAACL,IAAI,CAACyC,MAAD,CAAT,EAAmB;AACjBoB,IAAAA,cAAc,CAACpB,MAAD,EAASpC,OAAT,EAAkBE,MAAlB,CAAd;AACD;;AAED,SAAOiC,SAAS,CAACC,MAAD,CAAhB;AACD,CAXD;;AAaA,eAAe4B,OAAf;AACA,SAASrE,IAAT","sourcesContent":["import isPromise from \"is-promise\";\nimport defaults from \"./defaults\";\nimport { validateFunction, isUndefined } from \"./utils\";\nimport { LESYM, LE_PACK_SYM } from \"./consts\";\n\n//TODO: implement STATS\nconst getLE = obj => obj ? obj[LESYM] : null;\n\nconst getValidLE = obj => {\n  const le = getLE(obj);\n\n  if (!le) {\n    throw new Error(\"Didnt find LE internal object. Something very bad happened!\");\n  }\n\n  return le;\n};\n\nconst isLE = obj => !!getLE(obj);\n\nconst addRegistration = (obj, name, cb, once = false) => {\n  validateFunction(cb, \"cb\");\n  const le = getValidLE(obj);\n\n  if (!le.options.allowRegisterNonExistent && !~le.events.indexOf(name)) {\n    throw new Error(`Cannot register for event ${name.toString()} that wasn't already defined (allowRegisterNonExistent = false)`);\n  }\n\n  const namedRegistry = le.registry[name] || [];\n\n  if (!namedRegistry.find(r => r.cb === cb)) {\n    //only add same callback for a name once\n    namedRegistry.push({\n      name,\n      cb,\n      once\n    });\n    le.registry[name] = namedRegistry;\n  }\n\n  return () => unregister.call(obj, name, cb);\n};\n\nconst findRegistrations = (obj, name) => {\n  const registry = getValidLE(obj).registry;\n  return name ? registry[name] ? registry[name].slice() : [] : // $FlowFixMe - flow doesnt know about Array.prototype.flat yet...\n  Object.values(registry).flat();\n};\n\nconst publicMethods = {\n  \"on\": register,\n  \"once\": registerOnce,\n  \"off\": unregister,\n  \"getEvents\": getEvents\n};\n\nconst getPublicMethods = () => Object.entries(publicMethods).reduce((res, [key, m]) => {\n  res[key] = {\n    value: m\n  };\n  return res;\n}, {}); //using string keys here because can't rely on function names to stay after (babel/webpack) build\n\n\nconst apiMethods = {\n  \"trigger\": trigger,\n  \"addEvent\": addEvent,\n  \"removeEvent\": removeEvent,\n  \"hasEvent\": hasEvent,\n  \"hasEventRegistrations\": hasEventRegistrations,\n  \"assign\": assign\n};\n\nconst createApi = target => Object.keys(apiMethods).reduce((res, name) => {\n  res[name] = apiMethods[name].bind(target);\n  return res;\n}, {\n  target,\n  ...apiMethods\n});\n\nconst cleanRegistryForName = (obj, name, force = false) => {\n  const registry = getValidLE(obj).registry;\n\n  if (registry[name] && (force || !registry[name].length)) {\n    delete registry[name];\n  }\n};\n\nconst removeRegItem = (obj, name, cb) => {\n  const registry = getValidLE(obj).registry;\n\n  if (registry[name]) {\n    if (!cb) {\n      cleanRegistryForName(obj, name, true);\n    } else {\n      registry[name] = registry[name].filter(reg => reg.cb !== cb);\n      cleanRegistryForName(obj, name);\n    }\n  }\n};\n\nfunction register(name, cb) {\n  return addRegistration(this, name, cb);\n}\n\nfunction registerOnce(name, cb) {\n  return addRegistration(this, name, cb, true);\n}\n\nfunction unregister(name, cb) {\n  removeRegItem(this, name, cb);\n}\n\nfunction getEvents() {\n  return getValidLE(this).events.slice();\n}\n\nfunction trigger(name, ...args) {\n  const regs = findRegistrations(this, name);\n  let results;\n\n  if (regs.length) {\n    var _args$;\n\n    let packValue;\n\n    if (args.length === 1 && ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$[LE_PACK_SYM]) === true) {\n      //life-pack always returns array as params to spread\n      packValue = args[0].resolve();\n    }\n\n    results = regs.map(r => {\n      let result;\n\n      if (r.once) {\n        removeRegItem(this, name, r.cb);\n      }\n\n      if (packValue) {\n        result = r.cb(...packValue);\n      } else if (!args.length) {\n        result = r.cb();\n      } else if (args.length === 1) {\n        result = r.cb(args[0]);\n      } else if (args.length === 2) {\n        result = r.cb(args[0], args[1]);\n      } else if (args.length === 3) {\n        result = r.cb(args[0], args[1], args[2]);\n      } else {\n        result = r.cb(...args);\n      }\n\n      return result;\n    }).filter(result => !isUndefined(result)).map(result => isPromise(result) ? result : Promise.resolve(result));\n  }\n\n  return results && (results.length ? results : undefined);\n} //registry, events, stats become shared\n\n\nfunction assign(toObj) {\n  const le = getValidLE(this);\n  defineLifeData(toObj, le.options, le.events, le.registry, le.stats);\n  return createApi(toObj);\n}\n\nfunction addEvent(name) {\n  const le = getValidLE(this);\n\n  if (le.options.canAddEvents) {\n    const index = le.events.indexOf(name);\n\n    if (!~index) {\n      le.events.push(name);\n    } else {\n      throw new Error(`Event '${name}' already defined`);\n    }\n  } else {\n    throw new Error(\"Cannot add new events (canAddEvents = false)\");\n  }\n}\n\nfunction removeEvent(name) {\n  const le = getValidLE(this);\n\n  if (le.options.canRemoveEvents) {\n    const index = le.events.indexOf(name);\n    le.events.splice(index, 1);\n  } else {\n    throw new Error(\"Cannot remove events (canRemoveEvents = false)\");\n  }\n}\n\nfunction hasEvent(name) {\n  const le = getValidLE(this);\n  return !!~le.events.indexOf(name);\n}\n\nfunction hasEventRegistrations(name) {\n  return !!findRegistrations(this, name).length;\n} // function getStats(name?: any) {\n//\n// }\n\n\nconst defineLifeData = (target, options, events = [], registry = {}, stats = {}) => {\n  Object.defineProperties(target, {\n    [LESYM]: {\n      value: Object.seal({\n        registry,\n        events,\n        options,\n        stats\n      })\n    },\n    ...getPublicMethods()\n  });\n};\n\nconst addLife = (target, events = [], options) => {\n  target = target || {};\n  options = { ...defaults,\n    ...options\n  };\n\n  if (!isLE(target)) {\n    defineLifeData(target, options, events);\n  }\n\n  return createApi(target);\n};\n\nexport default addLife;\nexport { isLE };"]},"metadata":{},"sourceType":"module"}