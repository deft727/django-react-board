{"ast":null,"code":"import _objectSpread from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { BATCH_STATES, logger, merge, FILE_STATES } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nvar BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\nvar BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED];\n\nvar getBatchFromState = function getBatchFromState(state, id) {\n  return state.batches[id].batch;\n};\n\nvar getBatch = function getBatch(queue, id) {\n  return getBatchFromState(queue.getState(), id);\n};\n\nvar isItemBelongsToBatch = function isItemBelongsToBatch(queue, itemId, batchId) {\n  return queue.getState().items[itemId].batchId === batchId;\n};\n\nvar getBatchDataFromItemId = function getBatchDataFromItemId(queue, itemId) {\n  var state = queue.getState();\n  var item = state.items[itemId];\n  return state.batches[item.batchId];\n};\n\nvar getBatchFromItemId = function getBatchFromItemId(queue, itemId) {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\n\nvar removeBatchItems = function removeBatchItems(queue, batchId) {\n  var batch = getBatch(queue, batchId);\n  queue.updateState(function (state) {\n    batch.items.forEach(function (_ref) {\n      var id = _ref.id;\n      delete state.items[id];\n      var index = state.itemQueue.indexOf(id);\n\n      if (~index) {\n        state.itemQueue.splice(index, 1);\n      }\n    });\n  });\n};\n\nvar removeBatch = function removeBatch(queue, batchId) {\n  queue.updateState(function (state) {\n    delete state.batches[batchId];\n  });\n};\n\nvar cancelBatchForItem = function cancelBatchForItem(queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId),\n      batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.batchHelpers: cancelling batch: \", {\n    batch: batch\n  });\n  queue.updateState(function (state) {\n    var batch = getBatchFromState(state, batchId);\n    batch.state = BATCH_STATES.CANCELLED;\n  });\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\n\nvar isNewBatchStarting = function isNewBatchStarting(queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\n\nvar loadNewBatchForItem = function loadNewBatchForItem(queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(function (isCancelled) {\n    if (!isCancelled) {\n      queue.updateState(function (state) {\n        state.currentBatch = batch.id;\n      });\n    }\n\n    return !isCancelled;\n  });\n};\n\nvar cleanUpFinishedBatches = function cleanUpFinishedBatches(queue) {\n  //TODO: schedule clean up on requestAnimationFrame\n  var state = queue.getState();\n  Object.keys(state.batches).forEach(function (batchId) {\n    var _state$batches$batchI = state.batches[batchId],\n        batch = _state$batches$batchI.batch,\n        finishedCounter = _state$batches$batchI.finishedCounter;\n    var orgItemCount = batch.orgItemCount; //shouldnt be the case, but if wasnt cleaned before, it will now\n\n    var alreadyFinalized = getIsBatchFinalized(batch);\n\n    if (orgItemCount === finishedCounter) {\n      queue.updateState(function (state) {\n        var batch = getBatchFromState(state, batchId); //set batch state to FINISHED before triggering event and removing it from queue\n\n        batch.state = alreadyFinalized ? batch.state : BATCH_STATES.FINISHED;\n\n        if (state.currentBatch === batchId) {\n          state.currentBatch = null;\n        }\n      });\n      logger.debugLog(\"uploady.uploader.batchHelpers: cleaning up batch: \".concat(batch.id));\n\n      if (!alreadyFinalized) {\n        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n      }\n\n      removeBatchItems(queue, batchId);\n      removeBatch(queue, batchId);\n    }\n  });\n};\n\nvar triggerUploaderBatchEvent = function triggerUploaderBatchEvent(queue, batchId, event) {\n  var state = queue.getState(),\n      batch = getBatchFromState(state, batchId),\n      //get the most uptodate batch data\n  stateItems = state.items;\n\n  var eventBatch = _objectSpread(_objectSpread({}, unwrap(batch)), {}, {\n    items: batch.items.map(function (_ref2) {\n      var id = _ref2.id;\n      return unwrap(stateItems[id]);\n    })\n  });\n\n  queue.trigger(event, eventBatch);\n};\n\nvar getIsItemBatchReady = function getIsItemBatchReady(queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\n\nvar detachRecycledFromPreviousBatch = function detachRecycledFromPreviousBatch(queue, item) {\n  var previousBatch = item.previousBatch;\n\n  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {\n    var _getBatchFromItemId = getBatchFromItemId(queue, item.id),\n        batchId = _getBatchFromItemId.id;\n\n    if (batchId === previousBatch) {\n      queue.updateState(function (state) {\n        var batch = getBatchFromState(state, batchId);\n        var index = batch.items.findIndex(function (_ref3) {\n          var id = _ref3.id;\n          return id === item.id;\n        });\n\n        if (~index) {\n          batch.items.splice(index, 1);\n        }\n      });\n    }\n  }\n};\n\nvar preparePendingForUpload = function preparePendingForUpload(queue, uploadOptions) {\n  queue.updateState(function (state) {\n    //remove pending state from pending batches\n    Object.keys(state.batches).forEach(function (batchId) {\n      var batchData = state.batches[batchId];\n      var batch = batchData.batch,\n          batchOptions = batchData.batchOptions;\n\n      if (batch.state === BATCH_STATES.PENDING) {\n        batch.items.forEach(function (item) {\n          item.state = FILE_STATES.ADDED;\n        });\n        batch.state = BATCH_STATES.ADDED;\n        batchData.batchOptions = merge({}, batchOptions, uploadOptions);\n      }\n    });\n  });\n};\n\nvar removePendingBatches = function removePendingBatches(queue) {\n  var batches = queue.getState().batches;\n  Object.keys(batches).filter(function (batchId) {\n    return batches[batchId].batch.state === BATCH_STATES.PENDING;\n  }).forEach(function (batchId) {\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  });\n};\n\nvar incrementBatchFinishedCounter = function incrementBatchFinishedCounter(queue, batchId) {\n  queue.updateState(function (state) {\n    state.batches[batchId].finishedCounter += 1;\n  });\n};\n\nvar getIsBatchFinalized = function getIsBatchFinalized(batch) {\n  return BATCH_FINISHED_STATES.includes(batch.state);\n};\n\nexport { loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized };","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/uploader/lib/esm/queue/batchHelpers.js"],"names":["BATCH_STATES","logger","merge","FILE_STATES","unwrap","UPLOADER_EVENTS","BATCH_READY_STATES","ADDED","PROCESSING","UPLOADING","BATCH_FINISHED_STATES","ABORTED","CANCELLED","FINISHED","getBatchFromState","state","id","batches","batch","getBatch","queue","getState","isItemBelongsToBatch","itemId","batchId","items","getBatchDataFromItemId","item","getBatchFromItemId","removeBatchItems","updateState","forEach","index","itemQueue","indexOf","splice","removeBatch","cancelBatchForItem","debugLog","triggerUploaderBatchEvent","BATCH_CANCEL","isNewBatchStarting","currentBatch","loadNewBatchForItem","runCancellable","BATCH_START","then","isCancelled","cleanUpFinishedBatches","Object","keys","finishedCounter","orgItemCount","alreadyFinalized","getIsBatchFinalized","BATCH_FINISH","event","stateItems","eventBatch","map","trigger","getIsItemBatchReady","includes","detachRecycledFromPreviousBatch","previousBatch","recycled","findIndex","preparePendingForUpload","uploadOptions","batchData","batchOptions","PENDING","removePendingBatches","filter","incrementBatchFinishedCounter"],"mappings":"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","sourcesContent":["import { BATCH_STATES, logger, merge, FILE_STATES } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nconst BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\nconst BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED];\n\nconst getBatchFromState = (state, id) => state.batches[id].batch;\n\nconst getBatch = (queue, id) => {\n  return getBatchFromState(queue.getState(), id);\n};\n\nconst isItemBelongsToBatch = (queue, itemId, batchId) => {\n  return queue.getState().items[itemId].batchId === batchId;\n};\n\nconst getBatchDataFromItemId = (queue, itemId) => {\n  const state = queue.getState();\n  const item = state.items[itemId];\n  return state.batches[item.batchId];\n};\n\nconst getBatchFromItemId = (queue, itemId) => {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\n\nconst removeBatchItems = (queue, batchId) => {\n  const batch = getBatch(queue, batchId);\n  queue.updateState(state => {\n    batch.items.forEach(({\n      id\n    }) => {\n      delete state.items[id];\n      const index = state.itemQueue.indexOf(id);\n\n      if (~index) {\n        state.itemQueue.splice(index, 1);\n      }\n    });\n  });\n};\n\nconst removeBatch = (queue, batchId) => {\n  queue.updateState(state => {\n    delete state.batches[batchId];\n  });\n};\n\nconst cancelBatchForItem = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId),\n        batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.batchHelpers: cancelling batch: \", {\n    batch\n  });\n  queue.updateState(state => {\n    const batch = getBatchFromState(state, batchId);\n    batch.state = BATCH_STATES.CANCELLED;\n  });\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\n\nconst isNewBatchStarting = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\n\nconst loadNewBatchForItem = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(isCancelled => {\n    if (!isCancelled) {\n      queue.updateState(state => {\n        state.currentBatch = batch.id;\n      });\n    }\n\n    return !isCancelled;\n  });\n};\n\nconst cleanUpFinishedBatches = queue => {\n  //TODO: schedule clean up on requestAnimationFrame\n  const state = queue.getState();\n  Object.keys(state.batches).forEach(batchId => {\n    const {\n      batch,\n      finishedCounter\n    } = state.batches[batchId];\n    const {\n      orgItemCount\n    } = batch; //shouldnt be the case, but if wasnt cleaned before, it will now\n\n    const alreadyFinalized = getIsBatchFinalized(batch);\n\n    if (orgItemCount === finishedCounter) {\n      queue.updateState(state => {\n        const batch = getBatchFromState(state, batchId); //set batch state to FINISHED before triggering event and removing it from queue\n\n        batch.state = alreadyFinalized ? batch.state : BATCH_STATES.FINISHED;\n\n        if (state.currentBatch === batchId) {\n          state.currentBatch = null;\n        }\n      });\n      logger.debugLog(`uploady.uploader.batchHelpers: cleaning up batch: ${batch.id}`);\n\n      if (!alreadyFinalized) {\n        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n      }\n\n      removeBatchItems(queue, batchId);\n      removeBatch(queue, batchId);\n    }\n  });\n};\n\nconst triggerUploaderBatchEvent = (queue, batchId, event) => {\n  const state = queue.getState(),\n        batch = getBatchFromState(state, batchId),\n        //get the most uptodate batch data\n  stateItems = state.items;\n  const eventBatch = { ...unwrap(batch),\n    items: batch.items.map(({\n      id\n    }) => unwrap(stateItems[id]))\n  };\n  queue.trigger(event, eventBatch);\n};\n\nconst getIsItemBatchReady = (queue, itemId) => {\n  const batch = getBatchFromItemId(queue, itemId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\n\nconst detachRecycledFromPreviousBatch = (queue, item) => {\n  const {\n    previousBatch\n  } = item;\n\n  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {\n    const {\n      id: batchId\n    } = getBatchFromItemId(queue, item.id);\n\n    if (batchId === previousBatch) {\n      queue.updateState(state => {\n        const batch = getBatchFromState(state, batchId);\n        const index = batch.items.findIndex(({\n          id\n        }) => id === item.id);\n\n        if (~index) {\n          batch.items.splice(index, 1);\n        }\n      });\n    }\n  }\n};\n\nconst preparePendingForUpload = (queue, uploadOptions) => {\n  queue.updateState(state => {\n    //remove pending state from pending batches\n    Object.keys(state.batches).forEach(batchId => {\n      const batchData = state.batches[batchId];\n      const {\n        batch,\n        batchOptions\n      } = batchData;\n\n      if (batch.state === BATCH_STATES.PENDING) {\n        batch.items.forEach(item => {\n          item.state = FILE_STATES.ADDED;\n        });\n        batch.state = BATCH_STATES.ADDED;\n        batchData.batchOptions = merge({}, batchOptions, uploadOptions);\n      }\n    });\n  });\n};\n\nconst removePendingBatches = queue => {\n  const batches = queue.getState().batches;\n  Object.keys(batches).filter(batchId => batches[batchId].batch.state === BATCH_STATES.PENDING).forEach(batchId => {\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  });\n};\n\nconst incrementBatchFinishedCounter = (queue, batchId) => {\n  queue.updateState(state => {\n    state.batches[batchId].finishedCounter += 1;\n  });\n};\n\nconst getIsBatchFinalized = batch => BATCH_FINISHED_STATES.includes(batch.state);\n\nexport { loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized };"]},"metadata":{},"sourceType":"module"}