{"ast":null,"code":"import { triggerUpdater, isSamePropInArrays, FILE_STATES, logger, getMerge } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport processFinishedRequest from \"./processFinishedRequest\";\nvar mergeWithUndefined = getMerge({\n  undefinedOverwrites: true\n});\n\nvar triggerPreSendUpdate = function triggerPreSendUpdate(queue, items, options) {\n  return triggerUpdater(queue.trigger, UPLOADER_EVENTS.REQUEST_PRE_SEND, {\n    items: items,\n    options: options\n  }) // $FlowFixMe - https://github.com/facebook/flow/issues/8215\n  .then(function (updated) {\n    if (updated) {\n      logger.debugLog(\"uploader.queue: REQUEST_PRE_SEND event returned updated items/options\", updated);\n\n      if (updated.items) {\n        //can't change items count at this point.\n        if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, [\"id\", \"batchId\", \"recycled\"])) {\n          throw new Error(\"REQUEST_PRE_SEND event handlers must return same items with same ids\");\n        }\n\n        items = updated.items;\n      }\n\n      if (updated.options) {\n        options = mergeWithUndefined({}, options, updated.options);\n      }\n    }\n\n    return {\n      items: items,\n      options: options,\n      cancelled: updated === false\n    };\n  });\n};\n\nvar prepareAllowedItems = function prepareAllowedItems(queue, items) {\n  var allowedIds = items.map(function (item) {\n    return item.id;\n  });\n  queue.updateState(function (state) {\n    state.activeIds = state.activeIds.concat(allowedIds);\n  });\n  return triggerPreSendUpdate(queue, items, queue.getState().batches[items[0].batchId].batchOptions).then(function (prepared) {\n    if (!prepared.cancelled) {\n      //update potentially changed data back into queue state\n      queue.updateState(function (state) {\n        prepared.items.forEach(function (i) {\n          state.items[i.id] = i;\n        });\n        state.batches[items[0].batchId].batchOptions = prepared.options;\n      }); //use objects from internal state(proxies) - not objects from userland\n\n      var updatedState = queue.getState();\n      prepared.items = prepared.items.map(function (item) {\n        return updatedState.items[item.id];\n      });\n      prepared.options = updatedState.batches[items[0].batchId].batchOptions;\n    }\n\n    return prepared;\n  });\n};\n\nvar updateUploadingState = function updateUploadingState(queue, items, sendResult) {\n  queue.updateState(function (state) {\n    items.forEach(function (bi) {\n      var item = state.items[bi.id];\n      item.state = FILE_STATES.UPLOADING;\n      state.aborts[bi.id] = sendResult.abort;\n    });\n  });\n};\n\nvar sendAllowedItems = function sendAllowedItems(queue, itemsSendData, next) {\n  var items = itemsSendData.items,\n      options = itemsSendData.options;\n  var batch = queue.getState().batches[items[0].batchId].batch;\n  var sendResult;\n\n  try {\n    sendResult = queue.sender.send(items, batch, options);\n  } catch (ex) {\n    logger.debugLog(\"uploader.queue: sender failed with unexpected error\", ex); //provide error result so file(s) are marked as failed\n\n    sendResult = {\n      request: Promise.resolve({\n        status: 0,\n        state: FILE_STATES.ERROR,\n        response: ex.message\n      }),\n      abort: function abort() {\n        return false;\n      },\n      senderType: \"exception-handler\"\n    };\n  }\n\n  var _sendResult = sendResult,\n      request = _sendResult.request;\n  updateUploadingState(queue, items, sendResult);\n  return request //wait for server request to return\n  .then(function (requestInfo) {\n    var finishedData = items.map(function (item) {\n      return {\n        id: item.id,\n        info: requestInfo\n      };\n    });\n    processFinishedRequest(queue, finishedData, next);\n  });\n};\n\nvar reportCancelledItems = function reportCancelledItems(queue, items, cancelledResults, next) {\n  var cancelledItemsIds = cancelledResults.map(function (isCancelled, index) {\n    return isCancelled ? items[index].id : null;\n  }).filter(Boolean);\n\n  if (cancelledItemsIds.length) {\n    var finishedData = cancelledItemsIds.map(function (id) {\n      return {\n        id: id,\n        info: {\n          status: 0,\n          state: FILE_STATES.CANCELLED,\n          response: \"cancel\"\n        }\n      };\n    });\n    processFinishedRequest(queue, finishedData, next); //report about cancelled items\n  }\n\n  return !!cancelledItemsIds.length;\n}; //make sure item is still pending. Something might have changed while waiting for ITEM_START handling. Maybe someone called abort...\n\n\nvar getAllowedItem = function getAllowedItem(id, queue) {\n  return queue.getState().items[id];\n}; //send group of items to be uploaded\n\n\nvar processBatchItems = function processBatchItems(queue, ids, next) {\n  var state = queue.getState(); //ids will have more than one when grouping is allowed\n\n  var items = Object.values(state.items);\n  items = items.filter(function (item) {\n    return !!~ids.indexOf(item.id);\n  }); //allow user code cancel items from start event handler(s)\n\n  return Promise.all(items.map(function (i) {\n    return queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i);\n  })).then(function (cancelledResults) {\n    var allowedItems = cancelledResults.map(function (isCancelled, index) {\n      return isCancelled ? null : getAllowedItem(items[index].id, queue);\n    }).filter(Boolean);\n    return {\n      allowedItems: allowedItems,\n      cancelledResults: cancelledResults\n    };\n  }).then(function (_ref) {\n    var allowedItems = _ref.allowedItems,\n        cancelledResults = _ref.cancelledResults;\n    var afterPreparePromise = allowedItems.length ? prepareAllowedItems(queue, allowedItems).then() : Promise.resolve();\n    return afterPreparePromise.then(function (itemsSendData) {\n      var nextP;\n\n      if (itemsSendData) {\n        if (itemsSendData.cancelled) {\n          cancelledResults = ids.map(function () {\n            return true;\n          });\n        } else {\n          //we dont need to wait for the response here\n          sendAllowedItems(queue, itemsSendData, next);\n        }\n      } //if no cancelled we can go to process more items immediately (and not wait for upload responses)\n\n\n      if (!reportCancelledItems(queue, items, cancelledResults, next)) {\n        nextP = next(queue); //when concurrent is allowed, we can go ahead and process more\n      }\n\n      return nextP;\n    });\n  });\n};\n\nexport default processBatchItems;","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/uploader/lib/esm/queue/processBatchItems.js"],"names":["triggerUpdater","isSamePropInArrays","FILE_STATES","logger","getMerge","UPLOADER_EVENTS","processFinishedRequest","mergeWithUndefined","undefinedOverwrites","triggerPreSendUpdate","queue","items","options","trigger","REQUEST_PRE_SEND","then","updated","debugLog","length","Error","cancelled","prepareAllowedItems","allowedIds","map","item","id","updateState","state","activeIds","concat","getState","batches","batchId","batchOptions","prepared","forEach","i","updatedState","updateUploadingState","sendResult","bi","UPLOADING","aborts","abort","sendAllowedItems","itemsSendData","next","batch","sender","send","ex","request","Promise","resolve","status","ERROR","response","message","senderType","requestInfo","finishedData","info","reportCancelledItems","cancelledResults","cancelledItemsIds","isCancelled","index","filter","Boolean","CANCELLED","getAllowedItem","processBatchItems","ids","Object","values","indexOf","all","runCancellable","ITEM_START","allowedItems","afterPreparePromise","nextP"],"mappings":"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","sourcesContent":["import { triggerUpdater, isSamePropInArrays, FILE_STATES, logger, getMerge } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport processFinishedRequest from \"./processFinishedRequest\";\nconst mergeWithUndefined = getMerge({\n  undefinedOverwrites: true\n});\n\nconst triggerPreSendUpdate = (queue, items, options) => {\n  return triggerUpdater(queue.trigger, UPLOADER_EVENTS.REQUEST_PRE_SEND, {\n    items,\n    options\n  }) // $FlowFixMe - https://github.com/facebook/flow/issues/8215\n  .then(updated => {\n    if (updated) {\n      logger.debugLog(`uploader.queue: REQUEST_PRE_SEND event returned updated items/options`, updated);\n\n      if (updated.items) {\n        //can't change items count at this point.\n        if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, [\"id\", \"batchId\", \"recycled\"])) {\n          throw new Error(`REQUEST_PRE_SEND event handlers must return same items with same ids`);\n        }\n\n        items = updated.items;\n      }\n\n      if (updated.options) {\n        options = mergeWithUndefined({}, options, updated.options);\n      }\n    }\n\n    return {\n      items,\n      options,\n      cancelled: updated === false\n    };\n  });\n};\n\nconst prepareAllowedItems = (queue, items) => {\n  const allowedIds = items.map(item => item.id);\n  queue.updateState(state => {\n    state.activeIds = state.activeIds.concat(allowedIds);\n  });\n  return triggerPreSendUpdate(queue, items, queue.getState().batches[items[0].batchId].batchOptions).then(prepared => {\n    if (!prepared.cancelled) {\n      //update potentially changed data back into queue state\n      queue.updateState(state => {\n        prepared.items.forEach(i => {\n          state.items[i.id] = i;\n        });\n        state.batches[items[0].batchId].batchOptions = prepared.options;\n      }); //use objects from internal state(proxies) - not objects from userland\n\n      const updatedState = queue.getState();\n      prepared.items = prepared.items.map(item => updatedState.items[item.id]);\n      prepared.options = updatedState.batches[items[0].batchId].batchOptions;\n    }\n\n    return prepared;\n  });\n};\n\nconst updateUploadingState = (queue, items, sendResult) => {\n  queue.updateState(state => {\n    items.forEach(bi => {\n      const item = state.items[bi.id];\n      item.state = FILE_STATES.UPLOADING;\n      state.aborts[bi.id] = sendResult.abort;\n    });\n  });\n};\n\nconst sendAllowedItems = (queue, itemsSendData, next) => {\n  const {\n    items,\n    options\n  } = itemsSendData;\n  const batch = queue.getState().batches[items[0].batchId].batch;\n  let sendResult;\n\n  try {\n    sendResult = queue.sender.send(items, batch, options);\n  } catch (ex) {\n    logger.debugLog(`uploader.queue: sender failed with unexpected error`, ex); //provide error result so file(s) are marked as failed\n\n    sendResult = {\n      request: Promise.resolve({\n        status: 0,\n        state: FILE_STATES.ERROR,\n        response: ex.message\n      }),\n      abort: () => false,\n      senderType: \"exception-handler\"\n    };\n  }\n\n  const {\n    request\n  } = sendResult;\n  updateUploadingState(queue, items, sendResult);\n  return request //wait for server request to return\n  .then(requestInfo => {\n    const finishedData = items.map(item => ({\n      id: item.id,\n      info: requestInfo\n    }));\n    processFinishedRequest(queue, finishedData, next);\n  });\n};\n\nconst reportCancelledItems = (queue, items, cancelledResults, next) => {\n  const cancelledItemsIds = cancelledResults.map((isCancelled, index) => isCancelled ? items[index].id : null).filter(Boolean);\n\n  if (cancelledItemsIds.length) {\n    const finishedData = cancelledItemsIds.map(id => ({\n      id,\n      info: {\n        status: 0,\n        state: FILE_STATES.CANCELLED,\n        response: \"cancel\"\n      }\n    }));\n    processFinishedRequest(queue, finishedData, next); //report about cancelled items\n  }\n\n  return !!cancelledItemsIds.length;\n}; //make sure item is still pending. Something might have changed while waiting for ITEM_START handling. Maybe someone called abort...\n\n\nconst getAllowedItem = (id, queue) => queue.getState().items[id]; //send group of items to be uploaded\n\n\nconst processBatchItems = (queue, ids, next) => {\n  const state = queue.getState(); //ids will have more than one when grouping is allowed\n\n  let items = Object.values(state.items);\n  items = items.filter(item => !!~ids.indexOf(item.id)); //allow user code cancel items from start event handler(s)\n\n  return Promise.all(items.map(i => queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i))).then(cancelledResults => {\n    let allowedItems = cancelledResults.map((isCancelled, index) => isCancelled ? null : getAllowedItem(items[index].id, queue)).filter(Boolean);\n    return {\n      allowedItems,\n      cancelledResults\n    };\n  }).then(({\n    allowedItems,\n    cancelledResults\n  }) => {\n    const afterPreparePromise = allowedItems.length ? prepareAllowedItems(queue, allowedItems).then() : Promise.resolve();\n    return afterPreparePromise.then(itemsSendData => {\n      let nextP;\n\n      if (itemsSendData) {\n        if (itemsSendData.cancelled) {\n          cancelledResults = ids.map(() => true);\n        } else {\n          //we dont need to wait for the response here\n          sendAllowedItems(queue, itemsSendData, next);\n        }\n      } //if no cancelled we can go to process more items immediately (and not wait for upload responses)\n\n\n      if (!reportCancelledItems(queue, items, cancelledResults, next)) {\n        nextP = next(queue); //when concurrent is allowed, we can go ahead and process more\n      }\n\n      return nextP;\n    });\n  });\n};\n\nexport default processBatchItems;"]},"metadata":{},"sourceType":"module"}