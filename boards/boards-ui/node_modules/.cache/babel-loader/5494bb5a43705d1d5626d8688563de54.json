{"ast":null,"code":"import _slicedToArray from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { logger, hasWindow, isFunction } from \"@rpldy/shared\";\nimport createState from \"@rpldy/simple-state\";\nimport { SENDER_EVENTS, UPLOADER_EVENTS } from \"../consts\";\nimport processQueueNext from \"./processQueueNext\";\nimport * as abortMethods from \"./abort\";\nimport { detachRecycledFromPreviousBatch, getBatchFromState, preparePendingForUpload, removePendingBatches } from \"./batchHelpers\";\n\nvar createUploaderQueue = function createUploaderQueue(options, trigger, cancellable, sender, uploaderId) {\n  var _createState = createState({\n    itemQueue: [],\n    currentBatch: null,\n    batches: {},\n    items: {},\n    activeIds: [],\n    aborts: {}\n  }),\n      state = _createState.state,\n      update = _createState.update;\n\n  var getState = function getState() {\n    return state;\n  };\n\n  var updateState = function updateState(updater) {\n    update(updater);\n  };\n\n  var add = function add(item) {\n    if (state.items[item.id] && !item.recycled) {\n      throw new Error(\"Uploader queue conflict - item \".concat(item.id, \" already exists\"));\n    }\n\n    if (item.recycled) {\n      detachRecycledFromPreviousBatch(queueState, item);\n    }\n\n    updateState(function (state) {\n      state.items[item.id] = item;\n      state.itemQueue.push(item.id);\n    });\n  };\n\n  var handleItemProgress = function handleItemProgress(item, completed, loaded) {\n    if (state.items[item.id]) {\n      updateState(function (state) {\n        var stateItem = state.items[item.id];\n        stateItem.loaded = loaded;\n        stateItem.completed = completed;\n      }); //trigger item progress event for the outside\n\n      trigger(UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);\n    }\n  };\n\n  sender.on(SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);\n  sender.on(SENDER_EVENTS.BATCH_PROGRESS, function (batch) {\n    var _state$batches$batch$;\n\n    var batchItems = (_state$batches$batch$ = state.batches[batch.id]) === null || _state$batches$batch$ === void 0 ? void 0 : _state$batches$batch$.batch.items;\n\n    if (batchItems) {\n      var _batchItems$reduce = batchItems.reduce(function (res, item) {\n        res[0] += item.completed;\n        res[1] += item.loaded;\n        return res;\n      }, [0, 0]),\n          _batchItems$reduce2 = _slicedToArray(_batchItems$reduce, 2),\n          completed = _batchItems$reduce2[0],\n          loaded = _batchItems$reduce2[1];\n\n      updateState(function (state) {\n        var stateBatch = state.batches[batch.id].batch; //average of completed percentage for batch items\n\n        stateBatch.completed = completed / batchItems.length; //sum of loaded bytes for batch items\n\n        stateBatch.loaded = loaded;\n      });\n      trigger(UPLOADER_EVENTS.BATCH_PROGRESS, state.batches[batch.id].batch);\n    }\n  });\n  var queueState = {\n    uploaderId: uploaderId,\n    getOptions: function getOptions() {\n      return options;\n    },\n    getCurrentActiveCount: function getCurrentActiveCount() {\n      return state.activeIds.length;\n    },\n    getState: getState,\n    updateState: updateState,\n    trigger: trigger,\n    runCancellable: function runCancellable(name) {\n      if (!isFunction(cancellable)) {\n        //for flow :(\n        throw new Error(\"cancellable is of wrong type\");\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return cancellable.apply(void 0, [name].concat(args));\n    },\n    sender: sender,\n    handleItemProgress: handleItemProgress\n  };\n\n  if (hasWindow() && logger.isDebugOn()) {\n    window[\"__rpldy_\".concat(uploaderId, \"_queue_state\")] = queueState;\n  }\n\n  return {\n    updateState: updateState,\n    getState: queueState.getState,\n    runCancellable: queueState.runCancellable,\n    uploadBatch: function uploadBatch(batch, batchOptions) {\n      if (batchOptions) {\n        updateState(function (state) {\n          state.batches[batch.id].batchOptions = batchOptions;\n        });\n      }\n\n      processQueueNext(queueState);\n    },\n    addBatch: function addBatch(batch, batchOptions) {\n      updateState(function (state) {\n        state.batches[batch.id] = {\n          batch: batch,\n          batchOptions: batchOptions,\n          finishedCounter: 0\n        };\n      });\n      batch.items.forEach(add);\n      return getBatchFromState(state, batch.id);\n    },\n    abortItem: function abortItem(id) {\n      return abortMethods.abortItem(queueState, id, processQueueNext);\n    },\n    abortBatch: function abortBatch(id) {\n      abortMethods.abortBatch(queueState, id, processQueueNext);\n    },\n    abortAll: function abortAll() {\n      abortMethods.abortAll(queueState, processQueueNext);\n    },\n    clearPendingBatches: function clearPendingBatches() {\n      removePendingBatches(queueState);\n    },\n    uploadPendingBatches: function uploadPendingBatches(uploadOptions) {\n      preparePendingForUpload(queueState, uploadOptions);\n      processQueueNext(queueState);\n    }\n  };\n};\n\nexport default createUploaderQueue;","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/uploader/lib/esm/queue/uploaderQueue.js"],"names":["logger","hasWindow","isFunction","createState","SENDER_EVENTS","UPLOADER_EVENTS","processQueueNext","abortMethods","detachRecycledFromPreviousBatch","getBatchFromState","preparePendingForUpload","removePendingBatches","createUploaderQueue","options","trigger","cancellable","sender","uploaderId","itemQueue","currentBatch","batches","items","activeIds","aborts","state","update","getState","updateState","updater","add","item","id","recycled","Error","queueState","push","handleItemProgress","completed","loaded","stateItem","ITEM_PROGRESS","on","BATCH_PROGRESS","batch","_state$batches$batch$","batchItems","reduce","res","stateBatch","length","getOptions","getCurrentActiveCount","runCancellable","name","args","isDebugOn","window","uploadBatch","batchOptions","addBatch","finishedCounter","forEach","abortItem","abortBatch","abortAll","clearPendingBatches","uploadPendingBatches","uploadOptions"],"mappings":"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","sourcesContent":["import { logger, hasWindow, isFunction } from \"@rpldy/shared\";\nimport createState from \"@rpldy/simple-state\";\nimport { SENDER_EVENTS, UPLOADER_EVENTS } from \"../consts\";\nimport processQueueNext from \"./processQueueNext\";\nimport * as abortMethods from \"./abort\";\nimport { detachRecycledFromPreviousBatch, getBatchFromState, preparePendingForUpload, removePendingBatches } from \"./batchHelpers\";\n\nconst createUploaderQueue = (options, trigger, cancellable, sender, uploaderId) => {\n  const {\n    state,\n    update\n  } = createState({\n    itemQueue: [],\n    currentBatch: null,\n    batches: {},\n    items: {},\n    activeIds: [],\n    aborts: {}\n  });\n\n  const getState = () => state;\n\n  const updateState = updater => {\n    update(updater);\n  };\n\n  const add = item => {\n    if (state.items[item.id] && !item.recycled) {\n      throw new Error(`Uploader queue conflict - item ${item.id} already exists`);\n    }\n\n    if (item.recycled) {\n      detachRecycledFromPreviousBatch(queueState, item);\n    }\n\n    updateState(state => {\n      state.items[item.id] = item;\n      state.itemQueue.push(item.id);\n    });\n  };\n\n  const handleItemProgress = (item, completed, loaded) => {\n    if (state.items[item.id]) {\n      updateState(state => {\n        const stateItem = state.items[item.id];\n        stateItem.loaded = loaded;\n        stateItem.completed = completed;\n      }); //trigger item progress event for the outside\n\n      trigger(UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);\n    }\n  };\n\n  sender.on(SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);\n  sender.on(SENDER_EVENTS.BATCH_PROGRESS, batch => {\n    var _state$batches$batch$;\n\n    const batchItems = (_state$batches$batch$ = state.batches[batch.id]) === null || _state$batches$batch$ === void 0 ? void 0 : _state$batches$batch$.batch.items;\n\n    if (batchItems) {\n      const [completed, loaded] = batchItems.reduce((res, item) => {\n        res[0] += item.completed;\n        res[1] += item.loaded;\n        return res;\n      }, [0, 0]);\n      updateState(state => {\n        const stateBatch = state.batches[batch.id].batch; //average of completed percentage for batch items\n\n        stateBatch.completed = completed / batchItems.length; //sum of loaded bytes for batch items\n\n        stateBatch.loaded = loaded;\n      });\n      trigger(UPLOADER_EVENTS.BATCH_PROGRESS, state.batches[batch.id].batch);\n    }\n  });\n  const queueState = {\n    uploaderId,\n    getOptions: () => options,\n    getCurrentActiveCount: () => state.activeIds.length,\n    getState,\n    updateState,\n    trigger,\n    runCancellable: (name, ...args) => {\n      if (!isFunction(cancellable)) {\n        //for flow :(\n        throw new Error(\"cancellable is of wrong type\");\n      }\n\n      return cancellable(name, ...args);\n    },\n    sender,\n    handleItemProgress\n  };\n\n  if (hasWindow() && logger.isDebugOn()) {\n    window[`__rpldy_${uploaderId}_queue_state`] = queueState;\n  }\n\n  return {\n    updateState,\n    getState: queueState.getState,\n    runCancellable: queueState.runCancellable,\n    uploadBatch: (batch, batchOptions) => {\n      if (batchOptions) {\n        updateState(state => {\n          state.batches[batch.id].batchOptions = batchOptions;\n        });\n      }\n\n      processQueueNext(queueState);\n    },\n    addBatch: (batch, batchOptions) => {\n      updateState(state => {\n        state.batches[batch.id] = {\n          batch,\n          batchOptions,\n          finishedCounter: 0\n        };\n      });\n      batch.items.forEach(add);\n      return getBatchFromState(state, batch.id);\n    },\n    abortItem: id => {\n      return abortMethods.abortItem(queueState, id, processQueueNext);\n    },\n    abortBatch: id => {\n      abortMethods.abortBatch(queueState, id, processQueueNext);\n    },\n    abortAll: () => {\n      abortMethods.abortAll(queueState, processQueueNext);\n    },\n    clearPendingBatches: () => {\n      removePendingBatches(queueState);\n    },\n    uploadPendingBatches: uploadOptions => {\n      preparePendingForUpload(queueState, uploadOptions);\n      processQueueNext(queueState);\n    }\n  };\n};\n\nexport default createUploaderQueue;"]},"metadata":{},"sourceType":"module"}