{"ast":null,"code":"import _objectSpread from \"/home/user/Desktop/react_board/boards/boards-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { logger, FILE_STATES, request, parseResponseHeaders, pick, merge } from \"@rpldy/shared\";\nimport { XHR_SENDER_TYPE } from \"../consts\";\nimport MissingUrlError from \"../MissingUrlError\";\nimport prepareFormData from \"./prepareFormData\";\nexport var SUCCESS_CODES = [200, 201, 202, 203, 204];\n\nvar getRequestData = function getRequestData(items, options) {\n  var data;\n\n  if (options.sendWithFormData) {\n    logger.debugLog(\"uploady.sender: sending \".concat(items.length, \" item(s) as form data\"));\n    data = prepareFormData(items, options);\n  } else {\n    if (items.length > 1) {\n      throw new Error(\"XHR Sender - Request without form data can only contain 1 item. received \".concat(items.length));\n    }\n\n    var item = items[0];\n    logger.debugLog(\"uploady.sender: sending item \".concat(item.id, \" as request body\"));\n    data = item.file || item.url;\n  }\n\n  return data;\n};\n\nvar makeRequest = function makeRequest(items, url, options, onProgress, config) {\n  var xhr;\n  var data = config !== null && config !== void 0 && config.getRequestData ? config.getRequestData(items, options) : getRequestData(items, options);\n\n  var issueRequest = function issueRequest() {\n    var requestUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : url;\n    var requestData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : data;\n    var requestOptions = arguments.length > 2 ? arguments[2] : undefined;\n    requestOptions = merge(_objectSpread(_objectSpread({}, pick(options, [\"method\", \"headers\", \"withCredentials\"])), {}, {\n      preSend: function preSend(req) {\n        req.upload.onprogress = function (e) {\n          if (e.lengthComputable && onProgress) {\n            onProgress(e, items.slice());\n          }\n        };\n      }\n    }), requestOptions);\n    var realPXhr = request(requestUrl, requestData, requestOptions); // $FlowFixMe -\n\n    xhr = realPXhr.xhr;\n    return realPXhr;\n  }; //pXhr is a promise that resolves to the upload XHR\n\n\n  var pXhr = config !== null && config !== void 0 && config.preRequestHandler ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();\n  return {\n    url: url,\n    count: items.length,\n    pXhr: pXhr,\n    getXhr: function getXhr() {\n      return xhr;\n    },\n    aborted: false\n  };\n};\n\nvar parseResponseJson = function parseResponseJson(response, headers, options) {\n  var parsed = response;\n  var ct = headers === null || headers === void 0 ? void 0 : headers[\"content-type\"];\n\n  if (options.forceJsonResponse || ct !== null && ct !== void 0 && ct.includes(\"json\")) {\n    try {\n      parsed = JSON.parse(response);\n    } catch (_unused) {//silent fail\n    }\n  }\n\n  return parsed;\n};\n\nvar processResponse = function processResponse(sendRequest, options) {\n  return sendRequest.pXhr.then(function (xhr) {\n    var _options$formatServer, _options$formatServer2;\n\n    var state, response, status;\n    logger.debugLog(\"uploady.sender: received upload response \", xhr);\n    state = ~SUCCESS_CODES.indexOf(xhr.status) ? FILE_STATES.FINISHED : FILE_STATES.ERROR;\n    status = xhr.status;\n    var resHeaders = parseResponseHeaders(xhr);\n    response = {\n      data: (_options$formatServer = (_options$formatServer2 = options.formatServerResponse) === null || _options$formatServer2 === void 0 ? void 0 : _options$formatServer2.call(options, xhr.response, status, resHeaders)) !== null && _options$formatServer !== void 0 ? _options$formatServer : parseResponseJson(xhr.response, resHeaders, options),\n      headers: resHeaders\n    };\n    return {\n      status: status,\n      state: state,\n      response: response\n    };\n  }).catch(function (error) {\n    var state, response;\n\n    if (sendRequest.aborted) {\n      state = FILE_STATES.ABORTED;\n      response = \"aborted\";\n    } else {\n      logger.debugLog(\"uploady.sender: upload failed: \", error);\n      state = FILE_STATES.ERROR;\n      response = error;\n    }\n\n    return {\n      error: true,\n      state: state,\n      response: response,\n      status: 0\n    };\n  });\n};\n\nvar abortRequest = function abortRequest(sendRequest) {\n  var abortCalled = false;\n  var aborted = sendRequest.aborted,\n      getXhr = sendRequest.getXhr;\n  var xhr = getXhr();\n\n  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {\n    logger.debugLog(\"uploady.sender: cancelling request with \".concat(sendRequest.count, \" items to: \").concat(sendRequest.url));\n    xhr.abort();\n    sendRequest.aborted = true;\n    abortCalled = true;\n  }\n\n  return abortCalled;\n};\n\nvar getXhrSend = function getXhrSend(config) {\n  return function (items, url, options, onProgress) {\n    if (!url) {\n      throw new MissingUrlError(XHR_SENDER_TYPE);\n    }\n\n    logger.debugLog(\"uploady.sender: sending file: \", {\n      items: items,\n      url: url,\n      options: options\n    });\n    var sendRequest = makeRequest(items, url, options, onProgress, config);\n    return {\n      request: processResponse(sendRequest, options),\n      abort: function abort() {\n        return abortRequest(sendRequest);\n      },\n      senderType: XHR_SENDER_TYPE\n    };\n  };\n};\n\nexport default getXhrSend;","map":{"version":3,"sources":["/home/user/Desktop/react_board/boards/boards-ui/node_modules/@rpldy/sender/lib/esm/xhrSender/xhrSender.js"],"names":["logger","FILE_STATES","request","parseResponseHeaders","pick","merge","XHR_SENDER_TYPE","MissingUrlError","prepareFormData","SUCCESS_CODES","getRequestData","items","options","data","sendWithFormData","debugLog","length","Error","item","id","file","url","makeRequest","onProgress","config","xhr","issueRequest","requestUrl","requestData","requestOptions","preSend","req","upload","onprogress","e","lengthComputable","slice","realPXhr","pXhr","preRequestHandler","count","getXhr","aborted","parseResponseJson","response","headers","parsed","ct","forceJsonResponse","includes","JSON","parse","processResponse","sendRequest","then","_options$formatServer","_options$formatServer2","state","status","indexOf","FINISHED","ERROR","resHeaders","formatServerResponse","call","catch","error","ABORTED","abortRequest","abortCalled","readyState","abort","getXhrSend","senderType"],"mappings":"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","sourcesContent":["import { logger, FILE_STATES, request, parseResponseHeaders, pick, merge } from \"@rpldy/shared\";\nimport { XHR_SENDER_TYPE } from \"../consts\";\nimport MissingUrlError from \"../MissingUrlError\";\nimport prepareFormData from \"./prepareFormData\";\nexport const SUCCESS_CODES = [200, 201, 202, 203, 204];\n\nconst getRequestData = (items, options) => {\n  let data;\n\n  if (options.sendWithFormData) {\n    logger.debugLog(`uploady.sender: sending ${items.length} item(s) as form data`);\n    data = prepareFormData(items, options);\n  } else {\n    if (items.length > 1) {\n      throw new Error(`XHR Sender - Request without form data can only contain 1 item. received ${items.length}`);\n    }\n\n    const item = items[0];\n    logger.debugLog(`uploady.sender: sending item ${item.id} as request body`);\n    data = item.file || item.url;\n  }\n\n  return data;\n};\n\nconst makeRequest = (items, url, options, onProgress, config) => {\n  let xhr;\n  const data = config !== null && config !== void 0 && config.getRequestData ? config.getRequestData(items, options) : getRequestData(items, options);\n\n  const issueRequest = (requestUrl = url, requestData = data, requestOptions) => {\n    requestOptions = merge({ ...pick(options, [\"method\", \"headers\", \"withCredentials\"]),\n      preSend: req => {\n        req.upload.onprogress = e => {\n          if (e.lengthComputable && onProgress) {\n            onProgress(e, items.slice());\n          }\n        };\n      }\n    }, requestOptions);\n    const realPXhr = request(requestUrl, requestData, requestOptions); // $FlowFixMe -\n\n    xhr = realPXhr.xhr;\n    return realPXhr;\n  }; //pXhr is a promise that resolves to the upload XHR\n\n\n  const pXhr = config !== null && config !== void 0 && config.preRequestHandler ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();\n  return {\n    url,\n    count: items.length,\n    pXhr,\n    getXhr: () => xhr,\n    aborted: false\n  };\n};\n\nconst parseResponseJson = (response, headers, options) => {\n  let parsed = response;\n  const ct = headers === null || headers === void 0 ? void 0 : headers[\"content-type\"];\n\n  if (options.forceJsonResponse || ct !== null && ct !== void 0 && ct.includes(\"json\")) {\n    try {\n      parsed = JSON.parse(response);\n    } catch {//silent fail\n    }\n  }\n\n  return parsed;\n};\n\nconst processResponse = (sendRequest, options) => sendRequest.pXhr.then(xhr => {\n  var _options$formatServer, _options$formatServer2;\n\n  let state, response, status;\n  logger.debugLog(\"uploady.sender: received upload response \", xhr);\n  state = ~SUCCESS_CODES.indexOf(xhr.status) ? FILE_STATES.FINISHED : FILE_STATES.ERROR;\n  status = xhr.status;\n  const resHeaders = parseResponseHeaders(xhr);\n  response = {\n    data: (_options$formatServer = (_options$formatServer2 = options.formatServerResponse) === null || _options$formatServer2 === void 0 ? void 0 : _options$formatServer2.call(options, xhr.response, status, resHeaders)) !== null && _options$formatServer !== void 0 ? _options$formatServer : parseResponseJson(xhr.response, resHeaders, options),\n    headers: resHeaders\n  };\n  return {\n    status,\n    state,\n    response\n  };\n}).catch(error => {\n  let state, response;\n\n  if (sendRequest.aborted) {\n    state = FILE_STATES.ABORTED;\n    response = \"aborted\";\n  } else {\n    logger.debugLog(\"uploady.sender: upload failed: \", error);\n    state = FILE_STATES.ERROR;\n    response = error;\n  }\n\n  return {\n    error: true,\n    state,\n    response,\n    status: 0\n  };\n});\n\nconst abortRequest = sendRequest => {\n  let abortCalled = false;\n  const {\n    aborted,\n    getXhr\n  } = sendRequest;\n  const xhr = getXhr();\n\n  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {\n    logger.debugLog(`uploady.sender: cancelling request with ${sendRequest.count} items to: ${sendRequest.url}`);\n    xhr.abort();\n    sendRequest.aborted = true;\n    abortCalled = true;\n  }\n\n  return abortCalled;\n};\n\nconst getXhrSend = config => (items, url, options, onProgress) => {\n  if (!url) {\n    throw new MissingUrlError(XHR_SENDER_TYPE);\n  }\n\n  logger.debugLog(\"uploady.sender: sending file: \", {\n    items,\n    url,\n    options\n  });\n  const sendRequest = makeRequest(items, url, options, onProgress, config);\n  return {\n    request: processResponse(sendRequest, options),\n    abort: () => abortRequest(sendRequest),\n    senderType: XHR_SENDER_TYPE\n  };\n};\n\nexport default getXhrSend;"]},"metadata":{},"sourceType":"module"}